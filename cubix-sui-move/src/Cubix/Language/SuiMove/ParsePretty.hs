{- |
   AUTOGENERATED FILE - DO NOT EDIT MANUALLY

   This file was generated by the gen-parser executable from cubix-tree-sitter.

   To regenerate, run:
     cabal run gen-parser -- <path-to-grammar.json> \
       --start-rule-name <start-rule> \
       --module-name Cubix.Language.SuiMove.ParsePretty \
       --token-map <path-to-preserved_tokens.json> \
       -o <output-file>

   See CLAUDE.md for full instructions on adding language support.
-}

{-# LANGUAGE OverloadedStrings #-}
module Cubix.Language.SuiMove.ParsePretty where

import Control.Applicative.Combinators
import Control.Monad ((<=<))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Reader (ReaderT, runReaderT)
import Data.ByteString (ByteString)
import Data.ByteString.Char8 qualified as Char8
import Data.Comp.Multi (E (..))
import Data.Comp.Multi.Strategy.Classification (DynCase, caseE)
import Data.Foldable (foldrM)
import Data.Functor ((<&>))
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.List.NonEmpty (NonEmpty)
import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Maybe (catMaybes, fromJust)
import Data.Proxy (Proxy (..))
import Data.Text (Text)
import Data.Typeable (Typeable)
import Foreign.C.ConstPtr.Compat (ConstPtr (..))

import TreeSitter qualified as TS
import Text.Megaparsec qualified as Megaparsec
import Text.Megaparsec.Cubix qualified as Megaparsec.Cubix

import Cubix.ParsePretty (type RootSort)
import Cubix.TreeSitter
import Cubix.Language.SuiMove.Modularized

import Text.Pretty.Simple (pPrintDarkBg, pPrintLightBg)

parse' :: ReaderT TreeSitterEnv IO SomeTerm
parse' = do
  filepath <- getFilePath
  source <- getSource
  pTable <- liftIO . mkParseTable =<< getLanguage
  rootNode <- liftIO . TS.treeRootNode =<< getTree
  syntax filepath source pTable rootNode

parse :: FilePath -> IO (ConstPtr lang) -> IO (Maybe (MoveTerm (RootSort MoveSig)))
parse path getLang =
  newTreeSitterEnv path getLang
  >>= runReaderT parse'
  <&> caseE @_ @(RootSort MoveSig)

syntax :: FilePath -> ByteString -> ParseTable -> TS.Node -> ReaderT TreeSitterEnv IO SomeTerm
syntax path source pTable = fmap fromJust . go
  where
    pContent = Megaparsec.Cubix.getContent source
    getParser sym = IM.lookup (fromIntegral sym) (unParseTable pTable)
    go :: TS.Node -> ReaderT TreeSitterEnv IO (Maybe SomeTerm)
    go root = do
      extra <- liftIO $ TS.nodeIsExtra root
      if extra
        then pure Nothing
        else do
          range    <- liftIO $ nodeRange root
          span     <- liftIO $ nodeSpan path root
          symbolNo <- liftIO $ TS.nodeSymbol root
          case getParser symbolNo of
            Nothing -> do
              liftIO (TS.nodeTypeAsString root) >>= pPrintLightBg
              error $ "Unrecognized symbol: "
                   <> Prelude.show symbolNo
                   <> " at: "
                   <> Prelude.show span

            Just p -> do
              childNo <- liftIO $ TS.nodeChildCount root
              let childNums = [0..childNo - 1]
                  content = pContent range

              children <- if childNo == 0
                then
                  pure []
                else
                  catMaybes <$> mapM (go <=< (liftIO . TS.nodeChild root)) childNums
              case Megaparsec.runParser p path (Megaparsec.Cubix.Input content children) of
                Left err -> do
                  liftIO . putStrLn $ Megaparsec.errorBundlePretty err
                  pPrintLightBg =<< liftIO (TS.nodeTypeAsString root)
                  pPrintDarkBg children
                  error "no parse"
                Right item ->
                  pure (Just item)

-- --------------------------------------------------------------------------------
-- -- Parser 
-- --------------------------------------------------------------------------------
type SomeTerm = E MoveTerm
type Parser t = Megaparsec.Cubix.Parser MoveSig t
type TermParser l = Parser (MoveTerm l)
type SomeTermParser = Parser (E MoveTerm)

-- reify types
pMaybe :: Typeable l => TermParser l -> TermParser (Maybe l)
pMaybe = Megaparsec.Cubix.pMaybe
{-# INLINABLE pMaybe #-}

pPair :: (Typeable l, Typeable l') => TermParser l -> TermParser l' -> TermParser (l, l')
pPair = Megaparsec.Cubix.pPair
{-# INLINABLE pPair #-}

pSome :: Typeable l => TermParser l -> TermParser [l]
pSome = Megaparsec.Cubix.pSome
{-# INLINABLE pSome #-}

pMany :: Typeable l => TermParser l -> TermParser [l]
pMany = Megaparsec.Cubix.pMany
{-# INLINABLE pMany #-}

pSepBy :: Typeable l => TermParser l -> TermParser sep -> TermParser [l]
pSepBy = Megaparsec.Cubix.pSepBy
{-# INLINABLE pSepBy #-}

pSepBy1 :: Typeable l => TermParser l -> TermParser sep -> TermParser [l]
pSepBy1 = Megaparsec.Cubix.pSepBy1
{-# INLINABLE pSepBy1 #-}

pBetween :: Typeable l => TermParser open -> TermParser close -> TermParser l -> TermParser l
pBetween = Megaparsec.Cubix.pBetween
{-# INLINABLE pBetween #-}

pSort :: forall l. DynCase MoveTerm l => NonEmpty Char -> TermParser l
pSort = Megaparsec.Cubix.pSort @l
{-# INLINABLE pSort #-}

pSort' :: forall l. DynCase MoveTerm l => Proxy l -> NonEmpty Char -> TermParser l
pSort' = Megaparsec.Cubix.pSort' 
{-# INLINABLE pSort' #-}

pContent :: Parser Text
pContent = Megaparsec.Cubix.pContent
{-# INLINABLE pContent #-}

pExclamationMarkTok :: TermParser ExclamationMarkTokL
pExclamationMarkTok = ExclamationMarkTok' <$ Megaparsec.eof

pExclamationMarkEqualsSignTok :: TermParser ExclamationMarkEqualsSignTokL
pExclamationMarkEqualsSignTok = ExclamationMarkEqualsSignTok' <$ Megaparsec.eof

pNumberSignLeftSquareBracketTok :: TermParser NumberSignLeftSquareBracketTokL
pNumberSignLeftSquareBracketTok = NumberSignLeftSquareBracketTok' <$ Megaparsec.eof

pDollarSignTok :: TermParser DollarSignTokL
pDollarSignTok = DollarSignTok' <$ Megaparsec.eof

pPercentSignTok :: TermParser PercentSignTokL
pPercentSignTok = PercentSignTok' <$ Megaparsec.eof

pAmpersandTok :: TermParser AmpersandTokL
pAmpersandTok = AmpersandTok' <$ Megaparsec.eof

pAmpersandAmpersandTok :: TermParser AmpersandAmpersandTokL
pAmpersandAmpersandTok = AmpersandAmpersandTok' <$ Megaparsec.eof

pApostropheTok :: TermParser ApostropheTokL
pApostropheTok = ApostropheTok' <$ Megaparsec.eof

pLeftParenthesisTok :: TermParser LeftParenthesisTokL
pLeftParenthesisTok = LeftParenthesisTok' <$ Megaparsec.eof

pRightParenthesisTok :: TermParser RightParenthesisTokL
pRightParenthesisTok = RightParenthesisTok' <$ Megaparsec.eof

pAsteriskTok :: TermParser AsteriskTokL
pAsteriskTok = AsteriskTok' <$ Megaparsec.eof

pPlusSignTok :: TermParser PlusSignTokL
pPlusSignTok = PlusSignTok' <$ Megaparsec.eof

pCommaTok :: TermParser CommaTokL
pCommaTok = CommaTok' <$ Megaparsec.eof

pHyphenMinusTok :: TermParser HyphenMinusTokL
pHyphenMinusTok = HyphenMinusTok' <$ Megaparsec.eof

pHyphenMinusGreaterThanSignTok :: TermParser HyphenMinusGreaterThanSignTokL
pHyphenMinusGreaterThanSignTok = HyphenMinusGreaterThanSignTok' <$ Megaparsec.eof

pFullStopTok :: TermParser FullStopTokL
pFullStopTok = FullStopTok' <$ Megaparsec.eof

pFullStopFullStopTok :: TermParser FullStopFullStopTokL
pFullStopFullStopTok = FullStopFullStopTok' <$ Megaparsec.eof

pSolidusTok :: TermParser SolidusTokL
pSolidusTok = SolidusTok' <$ Megaparsec.eof

pSolidusAsteriskTok :: TermParser SolidusAsteriskTokL
pSolidusAsteriskTok = SolidusAsteriskTok' <$ Megaparsec.eof

pSolidusSolidusTok :: TermParser SolidusSolidusTokL
pSolidusSolidusTok = SolidusSolidusTok' <$ Megaparsec.eof

pColonTok :: TermParser ColonTokL
pColonTok = ColonTok' <$ Megaparsec.eof

pColonColonTok :: TermParser ColonColonTokL
pColonColonTok = ColonColonTok' <$ Megaparsec.eof

pSemicolonTok :: TermParser SemicolonTokL
pSemicolonTok = SemicolonTok' <$ Megaparsec.eof

pLessThanSignTok :: TermParser LessThanSignTokL
pLessThanSignTok = LessThanSignTok' <$ Megaparsec.eof

pLessThanSignLessThanSignTok :: TermParser LessThanSignLessThanSignTokL
pLessThanSignLessThanSignTok = LessThanSignLessThanSignTok' <$ Megaparsec.eof

pLessThanSignEqualsSignTok :: TermParser LessThanSignEqualsSignTokL
pLessThanSignEqualsSignTok = LessThanSignEqualsSignTok' <$ Megaparsec.eof

pEqualsSignTok :: TermParser EqualsSignTokL
pEqualsSignTok = EqualsSignTok' <$ Megaparsec.eof

pEqualsSignEqualsSignTok :: TermParser EqualsSignEqualsSignTokL
pEqualsSignEqualsSignTok = EqualsSignEqualsSignTok' <$ Megaparsec.eof

pEqualsSignEqualsSignGreaterThanSignTok :: TermParser EqualsSignEqualsSignGreaterThanSignTokL
pEqualsSignEqualsSignGreaterThanSignTok = EqualsSignEqualsSignGreaterThanSignTok' <$ Megaparsec.eof

pEqualsSignGreaterThanSignTok :: TermParser EqualsSignGreaterThanSignTokL
pEqualsSignGreaterThanSignTok = EqualsSignGreaterThanSignTok' <$ Megaparsec.eof

pGreaterThanSignTok :: TermParser GreaterThanSignTokL
pGreaterThanSignTok = GreaterThanSignTok' <$ Megaparsec.eof

pGreaterThanSignEqualsSignTok :: TermParser GreaterThanSignEqualsSignTokL
pGreaterThanSignEqualsSignTok = GreaterThanSignEqualsSignTok' <$ Megaparsec.eof

pGreaterThanSignGreaterThanSignTok :: TermParser GreaterThanSignGreaterThanSignTokL
pGreaterThanSignGreaterThanSignTok = GreaterThanSignGreaterThanSignTok' <$ Megaparsec.eof

pCommercialAtTok :: TermParser CommercialAtTokL
pCommercialAtTok = CommercialAtTok' <$ Megaparsec.eof

pLeftSquareBracketTok :: TermParser LeftSquareBracketTokL
pLeftSquareBracketTok = LeftSquareBracketTok' <$ Megaparsec.eof

pRightSquareBracketTok :: TermParser RightSquareBracketTokL
pRightSquareBracketTok = RightSquareBracketTok' <$ Megaparsec.eof

pCircumflexAccentTok :: TermParser CircumflexAccentTokL
pCircumflexAccentTok = CircumflexAccentTok' <$ Megaparsec.eof

pAbortTok :: TermParser AbortTokL
pAbortTok = AbortTok' <$ Megaparsec.eof

pAbortsIfTok :: TermParser AbortsIfTokL
pAbortsIfTok = AbortsIfTok' <$ Megaparsec.eof

pAbortsWithTok :: TermParser AbortsWithTokL
pAbortsWithTok = AbortsWithTok' <$ Megaparsec.eof

pAddressTok :: TermParser AddressTokL
pAddressTok = AddressTok' <$ Megaparsec.eof

pApplyTok :: TermParser ApplyTokL
pApplyTok = ApplyTok' <$ Megaparsec.eof

pAsTok :: TermParser AsTokL
pAsTok = AsTok' <$ Megaparsec.eof

pAssertTok :: TermParser AssertTokL
pAssertTok = AssertTok' <$ Megaparsec.eof

pAssumeTok :: TermParser AssumeTokL
pAssumeTok = AssumeTok' <$ Megaparsec.eof

pBoolTok :: TermParser BoolTokL
pBoolTok = BoolTok' <$ Megaparsec.eof

pBreakTok :: TermParser BreakTokL
pBreakTok = BreakTok' <$ Megaparsec.eof

pConstTok :: TermParser ConstTokL
pConstTok = ConstTok' <$ Megaparsec.eof

pContinueTok :: TermParser ContinueTokL
pContinueTok = ContinueTok' <$ Megaparsec.eof

pCopyTok :: TermParser CopyTokL
pCopyTok = CopyTok' <$ Megaparsec.eof

pDecreasesTok :: TermParser DecreasesTokL
pDecreasesTok = DecreasesTok' <$ Megaparsec.eof

pDropTok :: TermParser DropTokL
pDropTok = DropTok' <$ Megaparsec.eof

pElseTok :: TermParser ElseTokL
pElseTok = ElseTok' <$ Megaparsec.eof

pEnsuresTok :: TermParser EnsuresTokL
pEnsuresTok = EnsuresTok' <$ Megaparsec.eof

pEntryTok :: TermParser EntryTokL
pEntryTok = EntryTok' <$ Megaparsec.eof

pEnumTok :: TermParser EnumTokL
pEnumTok = EnumTok' <$ Megaparsec.eof

pExceptTok :: TermParser ExceptTokL
pExceptTok = ExceptTok' <$ Megaparsec.eof

pExistsTok :: TermParser ExistsTokL
pExistsTok = ExistsTok' <$ Megaparsec.eof

pExtendTok :: TermParser ExtendTokL
pExtendTok = ExtendTok' <$ Megaparsec.eof

pFalseTok :: TermParser FalseTokL
pFalseTok = FalseTok' <$ Megaparsec.eof

pForallTok :: TermParser ForallTokL
pForallTok = ForallTok' <$ Megaparsec.eof

pFriendTok :: TermParser FriendTokL
pFriendTok = FriendTok' <$ Megaparsec.eof

pFunTok :: TermParser FunTokL
pFunTok = FunTok' <$ Megaparsec.eof

pGlobalTok :: TermParser GlobalTokL
pGlobalTok = GlobalTok' <$ Megaparsec.eof

pHasTok :: TermParser HasTokL
pHasTok = HasTok' <$ Megaparsec.eof

pIfTok :: TermParser IfTokL
pIfTok = IfTok' <$ Megaparsec.eof

pInTok :: TermParser InTokL
pInTok = InTok' <$ Megaparsec.eof

pIncludeTok :: TermParser IncludeTokL
pIncludeTok = IncludeTok' <$ Megaparsec.eof

pInternalTok :: TermParser InternalTokL
pInternalTok = InternalTok' <$ Megaparsec.eof

pInvariantTok :: TermParser InvariantTokL
pInvariantTok = InvariantTok' <$ Megaparsec.eof

pKeyTok :: TermParser KeyTokL
pKeyTok = KeyTok' <$ Megaparsec.eof

pLetTok :: TermParser LetTokL
pLetTok = LetTok' <$ Megaparsec.eof

pLocalTok :: TermParser LocalTokL
pLocalTok = LocalTok' <$ Megaparsec.eof

pLoopTok :: TermParser LoopTokL
pLoopTok = LoopTok' <$ Megaparsec.eof

pMacroTok :: TermParser MacroTokL
pMacroTok = MacroTok' <$ Megaparsec.eof

pMatchTok :: TermParser MatchTokL
pMatchTok = MatchTok' <$ Megaparsec.eof

pModifiesTok :: TermParser ModifiesTokL
pModifiesTok = ModifiesTok' <$ Megaparsec.eof

pModuleTok :: TermParser ModuleTokL
pModuleTok = ModuleTok' <$ Megaparsec.eof

pMoveTok :: TermParser MoveTokL
pMoveTok = MoveTok' <$ Megaparsec.eof

pMutTok :: TermParser MutTokL
pMutTok = MutTok' <$ Megaparsec.eof

pNativeTok :: TermParser NativeTokL
pNativeTok = NativeTok' <$ Megaparsec.eof

pPackTok :: TermParser PackTokL
pPackTok = PackTok' <$ Megaparsec.eof

pPackageTok :: TermParser PackageTokL
pPackageTok = PackageTok' <$ Megaparsec.eof

pPhantomTok :: TermParser PhantomTokL
pPhantomTok = PhantomTok' <$ Megaparsec.eof

pPostTok :: TermParser PostTokL
pPostTok = PostTok' <$ Megaparsec.eof

pPragmaTok :: TermParser PragmaTokL
pPragmaTok = PragmaTok' <$ Megaparsec.eof

pPublicTok :: TermParser PublicTokL
pPublicTok = PublicTok' <$ Megaparsec.eof

pRequiresTok :: TermParser RequiresTokL
pRequiresTok = RequiresTok' <$ Megaparsec.eof

pReturnTok :: TermParser ReturnTokL
pReturnTok = ReturnTok' <$ Megaparsec.eof

pSchemaTok :: TermParser SchemaTokL
pSchemaTok = SchemaTok' <$ Megaparsec.eof

pSignerTok :: TermParser SignerTokL
pSignerTok = SignerTok' <$ Megaparsec.eof

pSpecTok :: TermParser SpecTokL
pSpecTok = SpecTok' <$ Megaparsec.eof

pStoreTok :: TermParser StoreTokL
pStoreTok = StoreTok' <$ Megaparsec.eof

pStructTok :: TermParser StructTokL
pStructTok = StructTok' <$ Megaparsec.eof

pSucceedsIfTok :: TermParser SucceedsIfTokL
pSucceedsIfTok = SucceedsIfTok' <$ Megaparsec.eof

pToTok :: TermParser ToTokL
pToTok = ToTok' <$ Megaparsec.eof

pTrueTok :: TermParser TrueTokL
pTrueTok = TrueTok' <$ Megaparsec.eof

pU128Tok :: TermParser U128TokL
pU128Tok = U128Tok' <$ Megaparsec.eof

pU16Tok :: TermParser U16TokL
pU16Tok = U16Tok' <$ Megaparsec.eof

pU256Tok :: TermParser U256TokL
pU256Tok = U256Tok' <$ Megaparsec.eof

pU32Tok :: TermParser U32TokL
pU32Tok = U32Tok' <$ Megaparsec.eof

pU64Tok :: TermParser U64TokL
pU64Tok = U64Tok' <$ Megaparsec.eof

pU8Tok :: TermParser U8TokL
pU8Tok = U8Tok' <$ Megaparsec.eof

pUnpackTok :: TermParser UnpackTokL
pUnpackTok = UnpackTok' <$ Megaparsec.eof

pUpdateTok :: TermParser UpdateTokL
pUpdateTok = UpdateTok' <$ Megaparsec.eof

pUseTok :: TermParser UseTokL
pUseTok = UseTok' <$ Megaparsec.eof

pVectorLessThanSignTok :: TermParser VectorLessThanSignTokL
pVectorLessThanSignTok = VectorLessThanSignTok' <$ Megaparsec.eof

pVectorLeftSquareBracketTok :: TermParser VectorLeftSquareBracketTokL
pVectorLeftSquareBracketTok = VectorLeftSquareBracketTok' <$ Megaparsec.eof

pWhereTok :: TermParser WhereTokL
pWhereTok = WhereTok' <$ Megaparsec.eof

pWhileTok :: TermParser WhileTokL
pWhileTok = WhileTok' <$ Megaparsec.eof

pWithTok :: TermParser WithTokL
pWithTok = WithTok' <$ Megaparsec.eof

pLeftCurlyBracketTok :: TermParser LeftCurlyBracketTokL
pLeftCurlyBracketTok = LeftCurlyBracketTok' <$ Megaparsec.eof

pVerticalLineTok :: TermParser VerticalLineTokL
pVerticalLineTok = VerticalLineTok' <$ Megaparsec.eof

pVerticalLineVerticalLineTok :: TermParser VerticalLineVerticalLineTokL
pVerticalLineVerticalLineTok = VerticalLineVerticalLineTok' <$ Megaparsec.eof

pRightCurlyBracketTok :: TermParser RightCurlyBracketTokL
pRightCurlyBracketTok = RightCurlyBracketTok' <$ Megaparsec.eof

pSourceFile :: TermParser SourceFileL
pSourceFile =
  SourceFile' <$> pMany (pSourceFileInternal0)

pSourceFileInternal0 :: TermParser SourceFileInternal0L
pSourceFileInternal0 =
  choice [ Megaparsec.try pSourceFileInternal0ModuleExtensionDefinition
         , Megaparsec.try pSourceFileInternal0ModuleDefinition
         ]
  where
    pSourceFileInternal0ModuleExtensionDefinition :: TermParser SourceFileInternal0L
    pSourceFileInternal0ModuleExtensionDefinition =
      SourceFileInternal0ModuleExtensionDefinition' <$> pSort @ModuleExtensionDefinitionL "module_extension_definition"
    pSourceFileInternal0ModuleDefinition :: TermParser SourceFileInternal0L
    pSourceFileInternal0ModuleDefinition =
      SourceFileInternal0ModuleDefinition' <$> pSort @ModuleDefinitionL "module_definition"

pModuleDefinition :: TermParser ModuleDefinitionL
pModuleDefinition =
  ModuleDefinition' <$> pSort @ModuleTokL "module_tok" <*> pSort @ModuleIdentityL "module_identity" <*> pSort @ModuleBodyL "module_body"

pModuleBody :: TermParser ModuleBodyL
pModuleBody =
  ModuleBody' <$> pModuleBodyInternal0 <*> pMany (pModuleBodyInternal1) <*> pMaybe (pSort @RightCurlyBracketTokL "}_tok")

pModuleBodyInternal0 :: TermParser ModuleBodyInternal0L
pModuleBodyInternal0 =
  choice [ Megaparsec.try pModuleBodyInternal0Semicolon
         , Megaparsec.try pModuleBodyInternal0LeftCurlyBracket
         ]
  where
    pModuleBodyInternal0Semicolon :: TermParser ModuleBodyInternal0L
    pModuleBodyInternal0Semicolon =
      ModuleBodyInternal0Semicolon' <$> pSort @SemicolonTokL ";_tok"
    pModuleBodyInternal0LeftCurlyBracket :: TermParser ModuleBodyInternal0L
    pModuleBodyInternal0LeftCurlyBracket =
      ModuleBodyInternal0LeftCurlyBracket' <$> pSort @LeftCurlyBracketTokL "{_tok"

pModuleBodyInternal1 :: TermParser ModuleBodyInternal1L
pModuleBodyInternal1 =
  choice [ Megaparsec.try pModuleBodyInternal1UseDeclaration
         , Megaparsec.try pModuleBodyInternal1FriendDeclaration
         , Megaparsec.try pModuleBodyInternal1Constant
         , Megaparsec.try pModuleBodyInternal1FunctionItem
         , Megaparsec.try pModuleBodyInternal1StructItem
         , Megaparsec.try pModuleBodyInternal1EnumItem
         , Megaparsec.try pModuleBodyInternal1SpecBlock
         ]
  where
    pModuleBodyInternal1UseDeclaration :: TermParser ModuleBodyInternal1L
    pModuleBodyInternal1UseDeclaration =
      ModuleBodyInternal1UseDeclaration' <$> pSort @UseDeclarationL "use_declaration"
    pModuleBodyInternal1FriendDeclaration :: TermParser ModuleBodyInternal1L
    pModuleBodyInternal1FriendDeclaration =
      ModuleBodyInternal1FriendDeclaration' <$> pSort @FriendDeclarationL "friend_declaration"
    pModuleBodyInternal1Constant :: TermParser ModuleBodyInternal1L
    pModuleBodyInternal1Constant =
      ModuleBodyInternal1Constant' <$> pSort @ConstantL "constant"
    pModuleBodyInternal1FunctionItem :: TermParser ModuleBodyInternal1L
    pModuleBodyInternal1FunctionItem =
      ModuleBodyInternal1FunctionItem' <$> pHiddenFunctionItem
    pModuleBodyInternal1StructItem :: TermParser ModuleBodyInternal1L
    pModuleBodyInternal1StructItem =
      ModuleBodyInternal1StructItem' <$> pHiddenStructItem
    pModuleBodyInternal1EnumItem :: TermParser ModuleBodyInternal1L
    pModuleBodyInternal1EnumItem =
      ModuleBodyInternal1EnumItem' <$> pHiddenEnumItem
    pModuleBodyInternal1SpecBlock :: TermParser ModuleBodyInternal1L
    pModuleBodyInternal1SpecBlock =
      ModuleBodyInternal1SpecBlock' <$> pSort @SpecBlockL "spec_block"

pHiddenEnumItem :: TermParser HiddenEnumItemL
pHiddenEnumItem =
  HiddenEnumItem' <$> pSort @EnumDefinitionL "enum_definition"

pEnumDefinition :: TermParser EnumDefinitionL
pEnumDefinition =
  EnumDefinition' <$> pMaybe (pSort @PublicTokL "public_tok") <*> pHiddenEnumSignature <*> pSort @EnumVariantsL "enum_variants" <*> pMaybe (pSort @PostfixAbilityDeclsL "postfix_ability_decls")

pHiddenEnumSignature :: TermParser HiddenEnumSignatureL
pHiddenEnumSignature =
  HiddenEnumSignature' <$> pSort @EnumTokL "enum_tok" <*> pHiddenEnumIdentifier <*> pMaybe (pSort @TypeParametersL "type_parameters") <*> pMaybe (pSort @AbilityDeclsL "ability_decls")

pHiddenEnumIdentifier :: TermParser HiddenEnumIdentifierL
pHiddenEnumIdentifier =
  HiddenEnumIdentifier' <$> pSort @IdentifierL "identifier"

pIdentifier :: TermParser IdentifierL
pIdentifier =
  Identifier' <$> pContent

pAbilityDecls :: TermParser AbilityDeclsL
pAbilityDecls =
  AbilityDecls' <$> pSort @HasTokL "has_tok" <*> pSepBy (pSort @AbilityL "ability") (pSort @CommaTokL ",_tok")

pAbility :: TermParser AbilityL
pAbility =
  choice [ Megaparsec.try pAbilityCopy
         , Megaparsec.try pAbilityDrop
         , Megaparsec.try pAbilityStore
         , Megaparsec.try pAbilityKey
         ]
  where
    pAbilityCopy :: TermParser AbilityL
    pAbilityCopy =
      AbilityCopy' <$> pSort @CopyTokL "copy_tok"
    pAbilityDrop :: TermParser AbilityL
    pAbilityDrop =
      AbilityDrop' <$> pSort @DropTokL "drop_tok"
    pAbilityStore :: TermParser AbilityL
    pAbilityStore =
      AbilityStore' <$> pSort @StoreTokL "store_tok"
    pAbilityKey :: TermParser AbilityL
    pAbilityKey =
      AbilityKey' <$> pSort @KeyTokL "key_tok"

pTypeParameters :: TermParser TypeParametersL
pTypeParameters =
  TypeParameters' <$> pBetween (pSort @LessThanSignTokL "<_tok") (pSort @GreaterThanSignTokL ">_tok") (pSepBy1 (pSort @TypeParameterL "type_parameter") (pSort @CommaTokL ",_tok"))

pTypeParameter :: TermParser TypeParameterL
pTypeParameter =
  TypeParameter' <$> pMaybe (pSort @DollarSignTokL "$_tok") <*> pMaybe (pSort @PhantomTokL "phantom_tok") <*> pHiddenTypeParameterIdentifier <*> pMaybe (pPair (pSort @ColonTokL ":_tok") (pSepBy1 (pSort @AbilityL "ability") (pSort @PlusSignTokL "+_tok")))

pHiddenTypeParameterIdentifier :: TermParser HiddenTypeParameterIdentifierL
pHiddenTypeParameterIdentifier =
  HiddenTypeParameterIdentifier' <$> pSort @IdentifierL "identifier"

pEnumVariants :: TermParser EnumVariantsL
pEnumVariants =
  EnumVariants' <$> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy (pSort @VariantL "variant") (pSort @CommaTokL ",_tok"))

pVariant :: TermParser VariantL
pVariant =
  Variant' <$> pHiddenVariantIdentifier <*> pMaybe (pSort @DatatypeFieldsL "datatype_fields")

pHiddenVariantIdentifier :: TermParser HiddenVariantIdentifierL
pHiddenVariantIdentifier =
  HiddenVariantIdentifier' <$> pSort @IdentifierL "identifier"

pDatatypeFields :: TermParser DatatypeFieldsL
pDatatypeFields =
  choice [ Megaparsec.try pDatatypeFieldsPositionalFields
         , Megaparsec.try pDatatypeFieldsNamedFields
         ]
  where
    pDatatypeFieldsPositionalFields :: TermParser DatatypeFieldsL
    pDatatypeFieldsPositionalFields =
      DatatypeFieldsPositionalFields' <$> pSort @PositionalFieldsL "positional_fields"
    pDatatypeFieldsNamedFields :: TermParser DatatypeFieldsL
    pDatatypeFieldsNamedFields =
      DatatypeFieldsNamedFields' <$> pSort @NamedFieldsL "named_fields"

pNamedFields :: TermParser NamedFieldsL
pNamedFields =
  NamedFields' <$> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy (pSort @FieldAnnotationL "field_annotation") (pSort @CommaTokL ",_tok"))

pFieldAnnotation :: TermParser FieldAnnotationL
pFieldAnnotation =
  FieldAnnotation' <$> pHiddenFieldIdentifier <*> pSort @ColonTokL ":_tok" <*> pHiddenType

pHiddenFieldIdentifier :: TermParser HiddenFieldIdentifierL
pHiddenFieldIdentifier =
  HiddenFieldIdentifier' <$> pSort @IdentifierL "identifier"

pHiddenType :: TermParser HiddenTypeL
pHiddenType =
  choice [ Megaparsec.try pHiddenTypeApplyType
         , Megaparsec.try pHiddenTypeRefType
         , Megaparsec.try pHiddenTypeTupleType
         , Megaparsec.try pHiddenTypeFunctionType
         , Megaparsec.try pHiddenTypePrimitiveType
         ]
  where
    pHiddenTypeApplyType :: TermParser HiddenTypeL
    pHiddenTypeApplyType =
      HiddenTypeApplyType' <$> pSort @ApplyTypeL "apply_type"
    pHiddenTypeRefType :: TermParser HiddenTypeL
    pHiddenTypeRefType =
      HiddenTypeRefType' <$> pSort @RefTypeL "ref_type"
    pHiddenTypeTupleType :: TermParser HiddenTypeL
    pHiddenTypeTupleType =
      HiddenTypeTupleType' <$> pSort @TupleTypeL "tuple_type"
    pHiddenTypeFunctionType :: TermParser HiddenTypeL
    pHiddenTypeFunctionType =
      HiddenTypeFunctionType' <$> pSort @FunctionTypeL "function_type"
    pHiddenTypePrimitiveType :: TermParser HiddenTypeL
    pHiddenTypePrimitiveType =
      HiddenTypePrimitiveType' <$> pSort @PrimitiveTypeL "primitive_type"

pApplyType :: TermParser ApplyTypeL
pApplyType =
  ApplyType' <$> pPair (pSort @ModuleAccessL "module_access") (pMaybe (pSort @TypeArgumentsL "type_arguments"))

pModuleAccess :: TermParser ModuleAccessL
pModuleAccess =
  choice [ Megaparsec.try pModuleAccess1
         , Megaparsec.try pModuleAccess2
         , Megaparsec.try pModuleAccessMember
         , Megaparsec.try pModuleAccess4
         , Megaparsec.try pModuleAccess5
         , Megaparsec.try pModuleAccess6
         , Megaparsec.try pModuleAccess7
         , Megaparsec.try pModuleAccess8
         , Megaparsec.try pModuleAccess9
         ]
  where
    pModuleAccess1 :: TermParser ModuleAccessL
    pModuleAccess1 =
      ModuleAccess1' <$> pSort @DollarSignTokL "$_tok" <*> pSort @IdentifierL "identifier"
    pModuleAccess2 :: TermParser ModuleAccessL
    pModuleAccess2 =
      ModuleAccess2' <$> pSort @CommercialAtTokL "@_tok" <*> pSort @IdentifierL "identifier"
    pModuleAccessMember :: TermParser ModuleAccessL
    pModuleAccessMember =
      ModuleAccessMember' <$> pHiddenReservedIdentifier
    pModuleAccess4 :: TermParser ModuleAccessL
    pModuleAccess4 =
      ModuleAccess4' <$> pSort @IdentifierL "identifier" <*> pMaybe (pSort @TypeArgumentsL "type_arguments")
    pModuleAccess5 :: TermParser ModuleAccessL
    pModuleAccess5 =
      ModuleAccess5' <$> pHiddenModuleIdentifier <*> pMaybe (pSort @TypeArgumentsL "type_arguments") <*> pSort @ColonColonTokL "::_tok" <*> pSort @IdentifierL "identifier"
    pModuleAccess6 :: TermParser ModuleAccessL
    pModuleAccess6 =
      ModuleAccess6' <$> pSort @ModuleIdentityL "module_identity" <*> pSort @ColonColonTokL "::_tok" <*> pSort @IdentifierL "identifier" <*> pSort @TypeArgumentsL "type_arguments"
    pModuleAccess7 :: TermParser ModuleAccessL
    pModuleAccess7 =
      ModuleAccess7' <$> pSort @ModuleIdentityL "module_identity" <*> pMaybe (pSort @TypeArgumentsL "type_arguments")
    pModuleAccess8 :: TermParser ModuleAccessL
    pModuleAccess8 =
      ModuleAccess8' <$> pSort @ModuleIdentityL "module_identity" <*> pMaybe (pSort @TypeArgumentsL "type_arguments") <*> pSort @ColonColonTokL "::_tok" <*> pSort @IdentifierL "identifier"
    pModuleAccess9 :: TermParser ModuleAccessL
    pModuleAccess9 =
      ModuleAccess9' <$> pSort @ModuleIdentityL "module_identity" <*> pSort @ColonColonTokL "::_tok" <*> pSort @IdentifierL "identifier" <*> pMaybe (pSort @TypeArgumentsL "type_arguments") <*> pSort @ColonColonTokL "::_tok" <*> pSort @IdentifierL "identifier"

pHiddenModuleIdentifier :: TermParser HiddenModuleIdentifierL
pHiddenModuleIdentifier =
  HiddenModuleIdentifier' <$> pSort @IdentifierL "identifier"

pHiddenReservedIdentifier :: TermParser HiddenReservedIdentifierL
pHiddenReservedIdentifier =
  choice [ Megaparsec.try pHiddenReservedIdentifierForall
         , Megaparsec.try pHiddenReservedIdentifierExists
         , Megaparsec.try pHiddenReservedIdentifierSpec
         ]
  where
    pHiddenReservedIdentifierForall :: TermParser HiddenReservedIdentifierL
    pHiddenReservedIdentifierForall =
      HiddenReservedIdentifierForall' <$> pHiddenForall
    pHiddenReservedIdentifierExists :: TermParser HiddenReservedIdentifierL
    pHiddenReservedIdentifierExists =
      HiddenReservedIdentifierExists' <$> pHiddenExists
    pHiddenReservedIdentifierSpec :: TermParser HiddenReservedIdentifierL
    pHiddenReservedIdentifierSpec =
      HiddenReservedIdentifierSpec' <$> pSort @SpecTokL "spec_tok"

pHiddenExists :: TermParser HiddenExistsL
pHiddenExists =
  HiddenExists' <$> pSort @ExistsTokL "exists_tok"

pHiddenForall :: TermParser HiddenForallL
pHiddenForall =
  HiddenForall' <$> pSort @ForallTokL "forall_tok"

pModuleIdentity :: TermParser ModuleIdentityL
pModuleIdentity =
  ModuleIdentity' <$> pModuleIdentityInternal0 <*> pSort @ColonColonTokL "::_tok" <*> pHiddenModuleIdentifier

pModuleIdentityInternal0 :: TermParser ModuleIdentityInternal0L
pModuleIdentityInternal0 =
  choice [ Megaparsec.try pModuleIdentityInternal0NumLiteral
         , Megaparsec.try pModuleIdentityInternal0ModuleIdentifier
         ]
  where
    pModuleIdentityInternal0NumLiteral :: TermParser ModuleIdentityInternal0L
    pModuleIdentityInternal0NumLiteral =
      ModuleIdentityInternal0NumLiteral' <$> pSort @NumLiteralL "num_literal"
    pModuleIdentityInternal0ModuleIdentifier :: TermParser ModuleIdentityInternal0L
    pModuleIdentityInternal0ModuleIdentifier =
      ModuleIdentityInternal0ModuleIdentifier' <$> pHiddenModuleIdentifier

pNumLiteral :: TermParser NumLiteralL
pNumLiteral =
  NumLiteral' <$> pContent <*> pMaybe (pNumLiteralInternal0)

pNumLiteralInternal0 :: TermParser NumLiteralInternal0L
pNumLiteralInternal0 =
  choice [ Megaparsec.try pNumLiteralInternal0U8
         , Megaparsec.try pNumLiteralInternal0U16
         , Megaparsec.try pNumLiteralInternal0U32
         , Megaparsec.try pNumLiteralInternal0U64
         , Megaparsec.try pNumLiteralInternal0U128
         , Megaparsec.try pNumLiteralInternal0U256
         ]
  where
    pNumLiteralInternal0U8 :: TermParser NumLiteralInternal0L
    pNumLiteralInternal0U8 =
      NumLiteralInternal0U8' <$> pSort @U8TokL "u8_tok"
    pNumLiteralInternal0U16 :: TermParser NumLiteralInternal0L
    pNumLiteralInternal0U16 =
      NumLiteralInternal0U16' <$> pSort @U16TokL "u16_tok"
    pNumLiteralInternal0U32 :: TermParser NumLiteralInternal0L
    pNumLiteralInternal0U32 =
      NumLiteralInternal0U32' <$> pSort @U32TokL "u32_tok"
    pNumLiteralInternal0U64 :: TermParser NumLiteralInternal0L
    pNumLiteralInternal0U64 =
      NumLiteralInternal0U64' <$> pSort @U64TokL "u64_tok"
    pNumLiteralInternal0U128 :: TermParser NumLiteralInternal0L
    pNumLiteralInternal0U128 =
      NumLiteralInternal0U128' <$> pSort @U128TokL "u128_tok"
    pNumLiteralInternal0U256 :: TermParser NumLiteralInternal0L
    pNumLiteralInternal0U256 =
      NumLiteralInternal0U256' <$> pSort @U256TokL "u256_tok"

pTypeArguments :: TermParser TypeArgumentsL
pTypeArguments =
  TypeArguments' <$> pBetween (pSort @LessThanSignTokL "<_tok") (pSort @GreaterThanSignTokL ">_tok") (pSepBy1 (pHiddenType) (pSort @CommaTokL ",_tok"))

pFunctionType :: TermParser FunctionTypeL
pFunctionType =
  FunctionType' <$> pSort @FunctionTypeParametersL "function_type_parameters" <*> pMaybe (pPair (pSort @HyphenMinusGreaterThanSignTokL "->_tok") (pHiddenType))

pFunctionTypeParameters :: TermParser FunctionTypeParametersL
pFunctionTypeParameters =
  FunctionTypeParameters' <$> pBetween (pSort @VerticalLineTokL "|_tok") (pSort @VerticalLineTokL "|_tok") (pSepBy (pHiddenType) (pSort @CommaTokL ",_tok"))

pPrimitiveType :: TermParser PrimitiveTypeL
pPrimitiveType =
  choice [ Megaparsec.try pPrimitiveTypeU8
         , Megaparsec.try pPrimitiveTypeU16
         , Megaparsec.try pPrimitiveTypeU32
         , Megaparsec.try pPrimitiveTypeU64
         , Megaparsec.try pPrimitiveTypeU128
         , Megaparsec.try pPrimitiveTypeU256
         , Megaparsec.try pPrimitiveTypeBool
         , Megaparsec.try pPrimitiveTypeAddress
         , Megaparsec.try pPrimitiveTypeSigner
         ]
  where
    pPrimitiveTypeU8 :: TermParser PrimitiveTypeL
    pPrimitiveTypeU8 =
      PrimitiveTypeU8' <$> pSort @U8TokL "u8_tok"
    pPrimitiveTypeU16 :: TermParser PrimitiveTypeL
    pPrimitiveTypeU16 =
      PrimitiveTypeU16' <$> pSort @U16TokL "u16_tok"
    pPrimitiveTypeU32 :: TermParser PrimitiveTypeL
    pPrimitiveTypeU32 =
      PrimitiveTypeU32' <$> pSort @U32TokL "u32_tok"
    pPrimitiveTypeU64 :: TermParser PrimitiveTypeL
    pPrimitiveTypeU64 =
      PrimitiveTypeU64' <$> pSort @U64TokL "u64_tok"
    pPrimitiveTypeU128 :: TermParser PrimitiveTypeL
    pPrimitiveTypeU128 =
      PrimitiveTypeU128' <$> pSort @U128TokL "u128_tok"
    pPrimitiveTypeU256 :: TermParser PrimitiveTypeL
    pPrimitiveTypeU256 =
      PrimitiveTypeU256' <$> pSort @U256TokL "u256_tok"
    pPrimitiveTypeBool :: TermParser PrimitiveTypeL
    pPrimitiveTypeBool =
      PrimitiveTypeBool' <$> pSort @BoolTokL "bool_tok"
    pPrimitiveTypeAddress :: TermParser PrimitiveTypeL
    pPrimitiveTypeAddress =
      PrimitiveTypeAddress' <$> pSort @AddressTokL "address_tok"
    pPrimitiveTypeSigner :: TermParser PrimitiveTypeL
    pPrimitiveTypeSigner =
      PrimitiveTypeSigner' <$> pSort @SignerTokL "signer_tok"

pRefType :: TermParser RefTypeL
pRefType =
  RefType' <$> pHiddenReference <*> pHiddenType

pHiddenReference :: TermParser HiddenReferenceL
pHiddenReference =
  choice [ Megaparsec.try pHiddenReferenceImmRef
         , Megaparsec.try pHiddenReferenceMutRef
         ]
  where
    pHiddenReferenceImmRef :: TermParser HiddenReferenceL
    pHiddenReferenceImmRef =
      HiddenReferenceImmRef' <$> pSort @ImmRefL "imm_ref"
    pHiddenReferenceMutRef :: TermParser HiddenReferenceL
    pHiddenReferenceMutRef =
      HiddenReferenceMutRef' <$> pSort @MutRefL "mut_ref"

pImmRef :: TermParser ImmRefL
pImmRef =
  ImmRef' <$> pSort @AmpersandTokL "&_tok"

pMutRef :: TermParser MutRefL
pMutRef =
  MutRef' <$> pSort @AmpersandTokL "&_tok" <*> pSort @MutTokL "mut_tok"

pTupleType :: TermParser TupleTypeL
pTupleType =
  TupleType' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pSepBy (pHiddenType) (pSort @CommaTokL ",_tok"))

pPositionalFields :: TermParser PositionalFieldsL
pPositionalFields =
  PositionalFields' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pSepBy (pHiddenType) (pSort @CommaTokL ",_tok"))

pPostfixAbilityDecls :: TermParser PostfixAbilityDeclsL
pPostfixAbilityDecls =
  PostfixAbilityDecls' <$> pBetween (pSort @HasTokL "has_tok") (pSort @SemicolonTokL ";_tok") (pSepBy (pSort @AbilityL "ability") (pSort @CommaTokL ",_tok"))

pHiddenFunctionItem :: TermParser HiddenFunctionItemL
pHiddenFunctionItem =
  choice [ Megaparsec.try pHiddenFunctionItemNativeFunctionDefinition
         , Megaparsec.try pHiddenFunctionItemMacroFunctionDefinition
         , Megaparsec.try pHiddenFunctionItemFunctionDefinition
         ]
  where
    pHiddenFunctionItemNativeFunctionDefinition :: TermParser HiddenFunctionItemL
    pHiddenFunctionItemNativeFunctionDefinition =
      HiddenFunctionItemNativeFunctionDefinition' <$> pSort @NativeFunctionDefinitionL "native_function_definition"
    pHiddenFunctionItemMacroFunctionDefinition :: TermParser HiddenFunctionItemL
    pHiddenFunctionItemMacroFunctionDefinition =
      HiddenFunctionItemMacroFunctionDefinition' <$> pSort @MacroFunctionDefinitionL "macro_function_definition"
    pHiddenFunctionItemFunctionDefinition :: TermParser HiddenFunctionItemL
    pHiddenFunctionItemFunctionDefinition =
      HiddenFunctionItemFunctionDefinition' <$> pSort @FunctionDefinitionL "function_definition"

pFunctionDefinition :: TermParser FunctionDefinitionL
pFunctionDefinition =
  FunctionDefinition' <$> pHiddenFunctionSignature <*> pSort @BlockL "block"

pHiddenFunctionSignature :: TermParser HiddenFunctionSignatureL
pHiddenFunctionSignature =
  HiddenFunctionSignature' <$> pMaybe (pSort @ModifierL "modifier") <*> pMaybe (pSort @ModifierL "modifier") <*> pMaybe (pSort @ModifierL "modifier") <*> pSort @FunTokL "fun_tok" <*> pHiddenFunctionIdentifier <*> pMaybe (pSort @TypeParametersL "type_parameters") <*> pSort @FunctionParametersL "function_parameters" <*> pMaybe (pSort @RetTypeL "ret_type")

pHiddenFunctionIdentifier :: TermParser HiddenFunctionIdentifierL
pHiddenFunctionIdentifier =
  HiddenFunctionIdentifier' <$> pSort @IdentifierL "identifier"

pFunctionParameters :: TermParser FunctionParametersL
pFunctionParameters =
  FunctionParameters' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pSepBy (pFunctionParametersInternal0) (pSort @CommaTokL ",_tok"))

pFunctionParametersInternal0 :: TermParser FunctionParametersInternal0L
pFunctionParametersInternal0 =
  choice [ Megaparsec.try pFunctionParametersInternal0MutFunctionParameter
         , Megaparsec.try pFunctionParametersInternal0FunctionParameter
         ]
  where
    pFunctionParametersInternal0MutFunctionParameter :: TermParser FunctionParametersInternal0L
    pFunctionParametersInternal0MutFunctionParameter =
      FunctionParametersInternal0MutFunctionParameter' <$> pSort @MutFunctionParameterL "mut_function_parameter"
    pFunctionParametersInternal0FunctionParameter :: TermParser FunctionParametersInternal0L
    pFunctionParametersInternal0FunctionParameter =
      FunctionParametersInternal0FunctionParameter' <$> pSort @FunctionParameterL "function_parameter"

pFunctionParameter :: TermParser FunctionParameterL
pFunctionParameter =
  FunctionParameter' <$> pFunctionParameterInternal0 <*> pSort @ColonTokL ":_tok" <*> pHiddenType

pFunctionParameterInternal0 :: TermParser FunctionParameterInternal0L
pFunctionParameterInternal0 =
  choice [ Megaparsec.try pFunctionParameterInternal0Name
         , Megaparsec.try pFunctionParameterInternal02
         ]
  where
    pFunctionParameterInternal0Name :: TermParser FunctionParameterInternal0L
    pFunctionParameterInternal0Name =
      FunctionParameterInternal0Name' <$> pHiddenVariableIdentifier
    pFunctionParameterInternal02 :: TermParser FunctionParameterInternal0L
    pFunctionParameterInternal02 =
      FunctionParameterInternal02' <$> pSort @DollarSignTokL "$_tok" <*> pHiddenVariableIdentifier

pHiddenVariableIdentifier :: TermParser HiddenVariableIdentifierL
pHiddenVariableIdentifier =
  HiddenVariableIdentifier' <$> pSort @IdentifierL "identifier"

pMutFunctionParameter :: TermParser MutFunctionParameterL
pMutFunctionParameter =
  MutFunctionParameter' <$> pSort @MutTokL "mut_tok" <*> pSort @FunctionParameterL "function_parameter"

pModifier :: TermParser ModifierL
pModifier =
  choice [ Megaparsec.try pModifier1
         , Megaparsec.try pModifierEntry
         , Megaparsec.try pModifierNative
         ]
  where
    pModifier1 :: TermParser ModifierL
    pModifier1 =
      Modifier1' <$> pSort @PublicTokL "public_tok" <*> pMaybe (pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pModifierInternal0))
    pModifierEntry :: TermParser ModifierL
    pModifierEntry =
      ModifierEntry' <$> pSort @EntryTokL "entry_tok"
    pModifierNative :: TermParser ModifierL
    pModifierNative =
      ModifierNative' <$> pSort @NativeTokL "native_tok"

pModifierInternal0 :: TermParser ModifierInternal0L
pModifierInternal0 =
  choice [ Megaparsec.try pModifierInternal0Package
         , Megaparsec.try pModifierInternal0Friend
         ]
  where
    pModifierInternal0Package :: TermParser ModifierInternal0L
    pModifierInternal0Package =
      ModifierInternal0Package' <$> pSort @PackageTokL "package_tok"
    pModifierInternal0Friend :: TermParser ModifierInternal0L
    pModifierInternal0Friend =
      ModifierInternal0Friend' <$> pSort @FriendTokL "friend_tok"

pRetType :: TermParser RetTypeL
pRetType =
  RetType' <$> pSort @ColonTokL ":_tok" <*> pHiddenType

pBlock :: TermParser BlockL
pBlock =
  Block' <$> pSort @LeftCurlyBracketTokL "{_tok" <*> pMany (pSort @UseDeclarationL "use_declaration") <*> pMany (pSort @BlockItemL "block_item") <*> pMaybe (pHiddenExpression) <*> pSort @RightCurlyBracketTokL "}_tok"

pHiddenExpression :: TermParser HiddenExpressionL
pHiddenExpression =
  choice [ Megaparsec.try pHiddenExpressionCallExpression
         , Megaparsec.try pHiddenExpressionMacroCallExpression
         , Megaparsec.try pHiddenExpressionLambdaExpression
         , Megaparsec.try pHiddenExpressionIfExpression
         , Megaparsec.try pHiddenExpressionWhileExpression
         , Megaparsec.try pHiddenExpressionReturnExpression
         , Megaparsec.try pHiddenExpressionAbortExpression
         , Megaparsec.try pHiddenExpressionAssignExpression
         , Megaparsec.try pHiddenExpressionUnaryExpression
         , Megaparsec.try pHiddenExpressionBinaryExpression
         , Megaparsec.try pHiddenExpressionCastExpression
         , Megaparsec.try pHiddenExpressionQuantifierExpression
         , Megaparsec.try pHiddenExpressionMatchExpression
         , Megaparsec.try pHiddenExpressionVectorExpression
         , Megaparsec.try pHiddenExpressionLoopExpression
         , Megaparsec.try pHiddenExpressionIdentifiedExpression
         ]
  where
    pHiddenExpressionCallExpression :: TermParser HiddenExpressionL
    pHiddenExpressionCallExpression =
      HiddenExpressionCallExpression' <$> pSort @CallExpressionL "call_expression"
    pHiddenExpressionMacroCallExpression :: TermParser HiddenExpressionL
    pHiddenExpressionMacroCallExpression =
      HiddenExpressionMacroCallExpression' <$> pSort @MacroCallExpressionL "macro_call_expression"
    pHiddenExpressionLambdaExpression :: TermParser HiddenExpressionL
    pHiddenExpressionLambdaExpression =
      HiddenExpressionLambdaExpression' <$> pSort @LambdaExpressionL "lambda_expression"
    pHiddenExpressionIfExpression :: TermParser HiddenExpressionL
    pHiddenExpressionIfExpression =
      HiddenExpressionIfExpression' <$> pSort @IfExpressionL "if_expression"
    pHiddenExpressionWhileExpression :: TermParser HiddenExpressionL
    pHiddenExpressionWhileExpression =
      HiddenExpressionWhileExpression' <$> pSort @WhileExpressionL "while_expression"
    pHiddenExpressionReturnExpression :: TermParser HiddenExpressionL
    pHiddenExpressionReturnExpression =
      HiddenExpressionReturnExpression' <$> pSort @ReturnExpressionL "return_expression"
    pHiddenExpressionAbortExpression :: TermParser HiddenExpressionL
    pHiddenExpressionAbortExpression =
      HiddenExpressionAbortExpression' <$> pSort @AbortExpressionL "abort_expression"
    pHiddenExpressionAssignExpression :: TermParser HiddenExpressionL
    pHiddenExpressionAssignExpression =
      HiddenExpressionAssignExpression' <$> pSort @AssignExpressionL "assign_expression"
    pHiddenExpressionUnaryExpression :: TermParser HiddenExpressionL
    pHiddenExpressionUnaryExpression =
      HiddenExpressionUnaryExpression' <$> pHiddenUnaryExpression
    pHiddenExpressionBinaryExpression :: TermParser HiddenExpressionL
    pHiddenExpressionBinaryExpression =
      HiddenExpressionBinaryExpression' <$> pSort @BinaryExpressionL "binary_expression"
    pHiddenExpressionCastExpression :: TermParser HiddenExpressionL
    pHiddenExpressionCastExpression =
      HiddenExpressionCastExpression' <$> pSort @CastExpressionL "cast_expression"
    pHiddenExpressionQuantifierExpression :: TermParser HiddenExpressionL
    pHiddenExpressionQuantifierExpression =
      HiddenExpressionQuantifierExpression' <$> pSort @QuantifierExpressionL "quantifier_expression"
    pHiddenExpressionMatchExpression :: TermParser HiddenExpressionL
    pHiddenExpressionMatchExpression =
      HiddenExpressionMatchExpression' <$> pSort @MatchExpressionL "match_expression"
    pHiddenExpressionVectorExpression :: TermParser HiddenExpressionL
    pHiddenExpressionVectorExpression =
      HiddenExpressionVectorExpression' <$> pSort @VectorExpressionL "vector_expression"
    pHiddenExpressionLoopExpression :: TermParser HiddenExpressionL
    pHiddenExpressionLoopExpression =
      HiddenExpressionLoopExpression' <$> pSort @LoopExpressionL "loop_expression"
    pHiddenExpressionIdentifiedExpression :: TermParser HiddenExpressionL
    pHiddenExpressionIdentifiedExpression =
      HiddenExpressionIdentifiedExpression' <$> pSort @IdentifiedExpressionL "identified_expression"

pHiddenUnaryExpression :: TermParser HiddenUnaryExpressionL
pHiddenUnaryExpression =
  HiddenUnaryExpression' <$> pHiddenUnaryExpressionInternal0

pHiddenUnaryExpressionInternal0 :: TermParser HiddenUnaryExpressionInternal0L
pHiddenUnaryExpressionInternal0 =
  choice [ Megaparsec.try pHiddenUnaryExpressionInternal0UnaryExpression
         , Megaparsec.try pHiddenUnaryExpressionInternal0BorrowExpression
         , Megaparsec.try pHiddenUnaryExpressionInternal0DereferenceExpression
         , Megaparsec.try pHiddenUnaryExpressionInternal0MoveOrCopyExpression
         , Megaparsec.try pHiddenUnaryExpressionInternal0ExpressionTerm
         ]
  where
    pHiddenUnaryExpressionInternal0UnaryExpression :: TermParser HiddenUnaryExpressionInternal0L
    pHiddenUnaryExpressionInternal0UnaryExpression =
      HiddenUnaryExpressionInternal0UnaryExpression' <$> pSort @UnaryExpressionL "unary_expression"
    pHiddenUnaryExpressionInternal0BorrowExpression :: TermParser HiddenUnaryExpressionInternal0L
    pHiddenUnaryExpressionInternal0BorrowExpression =
      HiddenUnaryExpressionInternal0BorrowExpression' <$> pSort @BorrowExpressionL "borrow_expression"
    pHiddenUnaryExpressionInternal0DereferenceExpression :: TermParser HiddenUnaryExpressionInternal0L
    pHiddenUnaryExpressionInternal0DereferenceExpression =
      HiddenUnaryExpressionInternal0DereferenceExpression' <$> pSort @DereferenceExpressionL "dereference_expression"
    pHiddenUnaryExpressionInternal0MoveOrCopyExpression :: TermParser HiddenUnaryExpressionInternal0L
    pHiddenUnaryExpressionInternal0MoveOrCopyExpression =
      HiddenUnaryExpressionInternal0MoveOrCopyExpression' <$> pSort @MoveOrCopyExpressionL "move_or_copy_expression"
    pHiddenUnaryExpressionInternal0ExpressionTerm :: TermParser HiddenUnaryExpressionInternal0L
    pHiddenUnaryExpressionInternal0ExpressionTerm =
      HiddenUnaryExpressionInternal0ExpressionTerm' <$> pHiddenExpressionTerm

pHiddenExpressionTerm :: TermParser HiddenExpressionTermL
pHiddenExpressionTerm =
  choice [ Megaparsec.try pHiddenExpressionTermCallExpression
         , Megaparsec.try pHiddenExpressionTermBreakExpression
         , Megaparsec.try pHiddenExpressionTermContinueExpression
         , Megaparsec.try pHiddenExpressionTermNameExpression
         , Megaparsec.try pHiddenExpressionTermMacroCallExpression
         , Megaparsec.try pHiddenExpressionTermPackExpression
         , Megaparsec.try pHiddenExpressionTermLiteralValue
         , Megaparsec.try pHiddenExpressionTermUnitExpression
         , Megaparsec.try pHiddenExpressionTermExpressionList
         , Megaparsec.try pHiddenExpressionTermAnnotationExpression
         , Megaparsec.try pHiddenExpressionTermBlock
         , Megaparsec.try pHiddenExpressionTermSpecBlock
         , Megaparsec.try pHiddenExpressionTermIfExpression
         , Megaparsec.try pHiddenExpressionTermDotExpression
         , Megaparsec.try pHiddenExpressionTermIndexExpression
         , Megaparsec.try pHiddenExpressionTermVectorExpression
         , Megaparsec.try pHiddenExpressionTermMatchExpression
         ]
  where
    pHiddenExpressionTermCallExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermCallExpression =
      HiddenExpressionTermCallExpression' <$> pSort @CallExpressionL "call_expression"
    pHiddenExpressionTermBreakExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermBreakExpression =
      HiddenExpressionTermBreakExpression' <$> pSort @BreakExpressionL "break_expression"
    pHiddenExpressionTermContinueExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermContinueExpression =
      HiddenExpressionTermContinueExpression' <$> pSort @ContinueExpressionL "continue_expression"
    pHiddenExpressionTermNameExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermNameExpression =
      HiddenExpressionTermNameExpression' <$> pSort @NameExpressionL "name_expression"
    pHiddenExpressionTermMacroCallExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermMacroCallExpression =
      HiddenExpressionTermMacroCallExpression' <$> pSort @MacroCallExpressionL "macro_call_expression"
    pHiddenExpressionTermPackExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermPackExpression =
      HiddenExpressionTermPackExpression' <$> pSort @PackExpressionL "pack_expression"
    pHiddenExpressionTermLiteralValue :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermLiteralValue =
      HiddenExpressionTermLiteralValue' <$> pHiddenLiteralValue
    pHiddenExpressionTermUnitExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermUnitExpression =
      HiddenExpressionTermUnitExpression' <$> pSort @UnitExpressionL "unit_expression"
    pHiddenExpressionTermExpressionList :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermExpressionList =
      HiddenExpressionTermExpressionList' <$> pSort @ExpressionListL "expression_list"
    pHiddenExpressionTermAnnotationExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermAnnotationExpression =
      HiddenExpressionTermAnnotationExpression' <$> pSort @AnnotationExpressionL "annotation_expression"
    pHiddenExpressionTermBlock :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermBlock =
      HiddenExpressionTermBlock' <$> pSort @BlockL "block"
    pHiddenExpressionTermSpecBlock :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermSpecBlock =
      HiddenExpressionTermSpecBlock' <$> pSort @SpecBlockL "spec_block"
    pHiddenExpressionTermIfExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermIfExpression =
      HiddenExpressionTermIfExpression' <$> pSort @IfExpressionL "if_expression"
    pHiddenExpressionTermDotExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermDotExpression =
      HiddenExpressionTermDotExpression' <$> pSort @DotExpressionL "dot_expression"
    pHiddenExpressionTermIndexExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermIndexExpression =
      HiddenExpressionTermIndexExpression' <$> pSort @IndexExpressionL "index_expression"
    pHiddenExpressionTermVectorExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermVectorExpression =
      HiddenExpressionTermVectorExpression' <$> pSort @VectorExpressionL "vector_expression"
    pHiddenExpressionTermMatchExpression :: TermParser HiddenExpressionTermL
    pHiddenExpressionTermMatchExpression =
      HiddenExpressionTermMatchExpression' <$> pSort @MatchExpressionL "match_expression"

pHiddenLiteralValue :: TermParser HiddenLiteralValueL
pHiddenLiteralValue =
  choice [ Megaparsec.try pHiddenLiteralValueAddressLiteral
         , Megaparsec.try pHiddenLiteralValueBoolLiteral
         , Megaparsec.try pHiddenLiteralValueNumLiteral
         , Megaparsec.try pHiddenLiteralValueHexStringLiteral
         , Megaparsec.try pHiddenLiteralValueByteStringLiteral
         , Megaparsec.try pHiddenLiteralValueStringLiteral
         ]
  where
    pHiddenLiteralValueAddressLiteral :: TermParser HiddenLiteralValueL
    pHiddenLiteralValueAddressLiteral =
      HiddenLiteralValueAddressLiteral' <$> pSort @AddressLiteralL "address_literal"
    pHiddenLiteralValueBoolLiteral :: TermParser HiddenLiteralValueL
    pHiddenLiteralValueBoolLiteral =
      HiddenLiteralValueBoolLiteral' <$> pSort @BoolLiteralL "bool_literal"
    pHiddenLiteralValueNumLiteral :: TermParser HiddenLiteralValueL
    pHiddenLiteralValueNumLiteral =
      HiddenLiteralValueNumLiteral' <$> pSort @NumLiteralL "num_literal"
    pHiddenLiteralValueHexStringLiteral :: TermParser HiddenLiteralValueL
    pHiddenLiteralValueHexStringLiteral =
      HiddenLiteralValueHexStringLiteral' <$> pSort @HexStringLiteralL "hex_string_literal"
    pHiddenLiteralValueByteStringLiteral :: TermParser HiddenLiteralValueL
    pHiddenLiteralValueByteStringLiteral =
      HiddenLiteralValueByteStringLiteral' <$> pSort @ByteStringLiteralL "byte_string_literal"
    pHiddenLiteralValueStringLiteral :: TermParser HiddenLiteralValueL
    pHiddenLiteralValueStringLiteral =
      HiddenLiteralValueStringLiteral' <$> pSort @StringLiteralL "string_literal"

pAddressLiteral :: TermParser AddressLiteralL
pAddressLiteral =
  AddressLiteral' <$> pContent

pBoolLiteral :: TermParser BoolLiteralL
pBoolLiteral =
  choice [ Megaparsec.try pBoolLiteralTrue
         , Megaparsec.try pBoolLiteralFalse
         ]
  where
    pBoolLiteralTrue :: TermParser BoolLiteralL
    pBoolLiteralTrue =
      BoolLiteralTrue' <$> pSort @TrueTokL "true_tok"
    pBoolLiteralFalse :: TermParser BoolLiteralL
    pBoolLiteralFalse =
      BoolLiteralFalse' <$> pSort @FalseTokL "false_tok"

pByteStringLiteral :: TermParser ByteStringLiteralL
pByteStringLiteral =
  ByteStringLiteral' <$> pContent

pHexStringLiteral :: TermParser HexStringLiteralL
pHexStringLiteral =
  HexStringLiteral' <$> pContent

pStringLiteral :: TermParser StringLiteralL
pStringLiteral =
  StringLiteral' <$> pContent

pAnnotationExpression :: TermParser AnnotationExpressionL
pAnnotationExpression =
  AnnotationExpression' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @ColonTokL ":_tok") (pHiddenExpression) <*> pHiddenType <*> pSort @RightParenthesisTokL ")_tok"

pBreakExpression :: TermParser BreakExpressionL
pBreakExpression =
  BreakExpression' <$> pSort @BreakTokL "break_tok" <*> pMaybe (pSort @LabelL "label") <*> pMaybe (pHiddenExpression)

pLabel :: TermParser LabelL
pLabel =
  Label' <$> pSort @ApostropheTokL "'_tok" <*> pSort @IdentifierL "identifier"

pCallExpression :: TermParser CallExpressionL
pCallExpression =
  CallExpression' <$> pPair (pSort @NameExpressionL "name_expression") (pSort @ArgListL "arg_list")

pArgList :: TermParser ArgListL
pArgList =
  ArgList' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pSepBy (pHiddenExpression) (pSort @CommaTokL ",_tok"))

pNameExpression :: TermParser NameExpressionL
pNameExpression =
  NameExpression' <$> pMaybe (pSort @ColonColonTokL "::_tok") <*> pSort @ModuleAccessL "module_access"

pContinueExpression :: TermParser ContinueExpressionL
pContinueExpression =
  ContinueExpression' <$> pSort @ContinueTokL "continue_tok" <*> pMaybe (pSort @LabelL "label")

pDotExpression :: TermParser DotExpressionL
pDotExpression =
  DotExpression' <$> pPair (pPair (pHiddenExpressionTerm) (pSort @FullStopTokL "._tok")) (pHiddenExpressionTerm)

pExpressionList :: TermParser ExpressionListL
pExpressionList =
  ExpressionList' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pSepBy1 (pHiddenExpression) (pSort @CommaTokL ",_tok"))

pIfExpression :: TermParser IfExpressionL
pIfExpression =
  IfExpression' <$> pPair (pPair (pPair (pSort @IfTokL "if_tok") (pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pHiddenExpression))) (pHiddenExpression)) (pMaybe (pPair (pSort @ElseTokL "else_tok") (pHiddenExpression)))

pIndexExpression :: TermParser IndexExpressionL
pIndexExpression =
  IndexExpression' <$> pPair (pHiddenExpressionTerm) (pBetween (pSort @LeftSquareBracketTokL "[_tok") (pSort @RightSquareBracketTokL "]_tok") (pSepBy (pHiddenExpression) (pSort @CommaTokL ",_tok")))

pMacroCallExpression :: TermParser MacroCallExpressionL
pMacroCallExpression =
  MacroCallExpression' <$> pSort @MacroModuleAccessL "macro_module_access" <*> pMaybe (pSort @TypeArgumentsL "type_arguments") <*> pSort @ArgListL "arg_list"

pMacroModuleAccess :: TermParser MacroModuleAccessL
pMacroModuleAccess =
  MacroModuleAccess' <$> pSort @ModuleAccessL "module_access" <*> pSort @ExclamationMarkTokL "!_tok"

pMatchExpression :: TermParser MatchExpressionL
pMatchExpression =
  MatchExpression' <$> pSort @MatchTokL "match_tok" <*> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pHiddenExpression) <*> pHiddenMatchBody

pHiddenMatchBody :: TermParser HiddenMatchBodyL
pHiddenMatchBody =
  HiddenMatchBody' <$> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy (pSort @MatchArmL "match_arm") (pSort @CommaTokL ",_tok"))

pMatchArm :: TermParser MatchArmL
pMatchArm =
  MatchArm' <$> pSort @BindListL "bind_list" <*> pMaybe (pSort @MatchConditionL "match_condition") <*> pSort @EqualsSignGreaterThanSignTokL "=>_tok" <*> pHiddenExpression

pBindList :: TermParser BindListL
pBindList =
  choice [ Megaparsec.try pBindListBind
         , Megaparsec.try pBindListCommaBindList
         , Megaparsec.try pBindListOrBindList
         ]
  where
    pBindListBind :: TermParser BindListL
    pBindListBind =
      BindListBind' <$> pHiddenBind
    pBindListCommaBindList :: TermParser BindListL
    pBindListCommaBindList =
      BindListCommaBindList' <$> pSort @CommaBindListL "comma_bind_list"
    pBindListOrBindList :: TermParser BindListL
    pBindListOrBindList =
      BindListOrBindList' <$> pSort @OrBindListL "or_bind_list"

pHiddenBind :: TermParser HiddenBindL
pHiddenBind =
  choice [ Megaparsec.try pHiddenBindBindInternal0
         , Megaparsec.try pHiddenBindBindUnpack
         , Megaparsec.try pHiddenBindAtBind
         , Megaparsec.try pHiddenBindLiteralValue
         ]
  where
    pHiddenBindBindInternal0 :: TermParser HiddenBindL
    pHiddenBindBindInternal0 =
      HiddenBindBindInternal0' <$> pHiddenBindInternal0
    pHiddenBindBindUnpack :: TermParser HiddenBindL
    pHiddenBindBindUnpack =
      HiddenBindBindUnpack' <$> pSort @BindUnpackL "bind_unpack"
    pHiddenBindAtBind :: TermParser HiddenBindL
    pHiddenBindAtBind =
      HiddenBindAtBind' <$> pSort @AtBindL "at_bind"
    pHiddenBindLiteralValue :: TermParser HiddenBindL
    pHiddenBindLiteralValue =
      HiddenBindLiteralValue' <$> pHiddenLiteralValue

pHiddenBindInternal0 :: TermParser HiddenBindInternal0L
pHiddenBindInternal0 =
  choice [ Megaparsec.try pHiddenBindInternal0MutBindVar
         , Megaparsec.try pHiddenBindInternal0VariableIdentifier
         ]
  where
    pHiddenBindInternal0MutBindVar :: TermParser HiddenBindInternal0L
    pHiddenBindInternal0MutBindVar =
      HiddenBindInternal0MutBindVar' <$> pSort @MutBindVarL "mut_bind_var"
    pHiddenBindInternal0VariableIdentifier :: TermParser HiddenBindInternal0L
    pHiddenBindInternal0VariableIdentifier =
      HiddenBindInternal0VariableIdentifier' <$> pHiddenVariableIdentifier

pMutBindVar :: TermParser MutBindVarL
pMutBindVar =
  MutBindVar' <$> pSort @MutTokL "mut_tok" <*> pHiddenVariableIdentifier

pAtBind :: TermParser AtBindL
pAtBind =
  AtBind' <$> pHiddenVariableIdentifier <*> pSort @CommercialAtTokL "@_tok" <*> pSort @BindListL "bind_list"

pBindUnpack :: TermParser BindUnpackL
pBindUnpack =
  BindUnpack' <$> pSort @NameExpressionL "name_expression" <*> pMaybe (pSort @BindFieldsL "bind_fields")

pBindFields :: TermParser BindFieldsL
pBindFields =
  choice [ Megaparsec.try pBindFieldsBindPositionalFields
         , Megaparsec.try pBindFieldsBindNamedFields
         ]
  where
    pBindFieldsBindPositionalFields :: TermParser BindFieldsL
    pBindFieldsBindPositionalFields =
      BindFieldsBindPositionalFields' <$> pSort @BindPositionalFieldsL "bind_positional_fields"
    pBindFieldsBindNamedFields :: TermParser BindFieldsL
    pBindFieldsBindNamedFields =
      BindFieldsBindNamedFields' <$> pSort @BindNamedFieldsL "bind_named_fields"

pBindNamedFields :: TermParser BindNamedFieldsL
pBindNamedFields =
  BindNamedFields' <$> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy (pBindNamedFieldsInternal0) (pSort @CommaTokL ",_tok"))

pBindNamedFieldsInternal0 :: TermParser BindNamedFieldsInternal0L
pBindNamedFieldsInternal0 =
  choice [ Megaparsec.try pBindNamedFieldsInternal0BindField
         , Megaparsec.try pBindNamedFieldsInternal0MutBindField
         ]
  where
    pBindNamedFieldsInternal0BindField :: TermParser BindNamedFieldsInternal0L
    pBindNamedFieldsInternal0BindField =
      BindNamedFieldsInternal0BindField' <$> pSort @BindFieldL "bind_field"
    pBindNamedFieldsInternal0MutBindField :: TermParser BindNamedFieldsInternal0L
    pBindNamedFieldsInternal0MutBindField =
      BindNamedFieldsInternal0MutBindField' <$> pSort @MutBindFieldL "mut_bind_field"

pBindField :: TermParser BindFieldL
pBindField =
  choice [ Megaparsec.try pBindField1
         , Megaparsec.try pBindFieldSpreadOperator
         ]
  where
    pBindField1 :: TermParser BindFieldL
    pBindField1 =
      BindField1' <$> pSort @BindListL "bind_list" <*> pMaybe (pPair (pSort @ColonTokL ":_tok") (pSort @BindListL "bind_list"))
    pBindFieldSpreadOperator :: TermParser BindFieldL
    pBindFieldSpreadOperator =
      BindFieldSpreadOperator' <$> pHiddenSpreadOperator

pHiddenSpreadOperator :: TermParser HiddenSpreadOperatorL
pHiddenSpreadOperator =
  HiddenSpreadOperator' <$> pSort @FullStopFullStopTokL ".._tok"

pMutBindField :: TermParser MutBindFieldL
pMutBindField =
  MutBindField' <$> pSort @MutTokL "mut_tok" <*> pSort @BindFieldL "bind_field"

pBindPositionalFields :: TermParser BindPositionalFieldsL
pBindPositionalFields =
  BindPositionalFields' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pSepBy (pBindNamedFieldsInternal0) (pSort @CommaTokL ",_tok"))

pCommaBindList :: TermParser CommaBindListL
pCommaBindList =
  CommaBindList' <$> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pSepBy (pHiddenBind) (pSort @CommaTokL ",_tok"))

pOrBindList :: TermParser OrBindListL
pOrBindList =
  OrBindList' <$> pMaybe (pSort @LeftParenthesisTokL "(_tok") <*> pSepBy1 (pPair (pPair (pMaybe (pSort @LeftParenthesisTokL "(_tok")) (pHiddenBind)) (pMaybe (pSort @RightParenthesisTokL ")_tok"))) (pSort @VerticalLineTokL "|_tok") <*> pMaybe (pSort @RightParenthesisTokL ")_tok")

pMatchCondition :: TermParser MatchConditionL
pMatchCondition =
  MatchCondition' <$> pSort @IfTokL "if_tok" <*> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pHiddenExpression)

pPackExpression :: TermParser PackExpressionL
pPackExpression =
  PackExpression' <$> pSort @NameExpressionL "name_expression" <*> pSort @FieldInitializeListL "field_initialize_list"

pFieldInitializeList :: TermParser FieldInitializeListL
pFieldInitializeList =
  FieldInitializeList' <$> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy (pSort @ExpFieldL "exp_field") (pSort @CommaTokL ",_tok"))

pExpField :: TermParser ExpFieldL
pExpField =
  ExpField' <$> pHiddenFieldIdentifier <*> pMaybe (pPair (pSort @ColonTokL ":_tok") (pHiddenExpression))

pSpecBlock :: TermParser SpecBlockL
pSpecBlock =
  SpecBlock' <$> pSort @SpecTokL "spec_tok" <*> pSpecBlockInternal0

pSpecBlockInternal0 :: TermParser SpecBlockInternal0L
pSpecBlockInternal0 =
  choice [ Megaparsec.try pSpecBlockInternal01
         , Megaparsec.try pSpecBlockInternal0SpecFunction
         ]
  where
    pSpecBlockInternal01 :: TermParser SpecBlockInternal0L
    pSpecBlockInternal01 =
      SpecBlockInternal01' <$> pMaybe (pHiddenSpecBlockTarget) <*> pSort @SpecBodyL "spec_body"
    pSpecBlockInternal0SpecFunction :: TermParser SpecBlockInternal0L
    pSpecBlockInternal0SpecFunction =
      SpecBlockInternal0SpecFunction' <$> pHiddenSpecFunction

pHiddenSpecBlockTarget :: TermParser HiddenSpecBlockTargetL
pHiddenSpecBlockTarget =
  choice [ Megaparsec.try pHiddenSpecBlockTargetIdentifier
         , Megaparsec.try pHiddenSpecBlockTargetModule
         , Megaparsec.try pHiddenSpecBlockTargetSpecBlockTargetSchema
         ]
  where
    pHiddenSpecBlockTargetIdentifier :: TermParser HiddenSpecBlockTargetL
    pHiddenSpecBlockTargetIdentifier =
      HiddenSpecBlockTargetIdentifier' <$> pSort @IdentifierL "identifier"
    pHiddenSpecBlockTargetModule :: TermParser HiddenSpecBlockTargetL
    pHiddenSpecBlockTargetModule =
      HiddenSpecBlockTargetModule' <$> pSort @ModuleTokL "module_tok"
    pHiddenSpecBlockTargetSpecBlockTargetSchema :: TermParser HiddenSpecBlockTargetL
    pHiddenSpecBlockTargetSpecBlockTargetSchema =
      HiddenSpecBlockTargetSpecBlockTargetSchema' <$> pSort @SpecBlockTargetSchemaL "spec_block_target_schema"

pSpecBlockTargetSchema :: TermParser SpecBlockTargetSchemaL
pSpecBlockTargetSchema =
  SpecBlockTargetSchema' <$> pSort @SchemaTokL "schema_tok" <*> pHiddenStructIdentifier <*> pMaybe (pSort @TypeParametersL "type_parameters")

pHiddenStructIdentifier :: TermParser HiddenStructIdentifierL
pHiddenStructIdentifier =
  HiddenStructIdentifier' <$> pSort @IdentifierL "identifier"

pHiddenSpecFunction :: TermParser HiddenSpecFunctionL
pHiddenSpecFunction =
  choice [ Megaparsec.try pHiddenSpecFunctionNativeSpecFunction
         , Megaparsec.try pHiddenSpecFunctionUsualSpecFunction
         , Megaparsec.try pHiddenSpecFunctionUninterpretedSpecFunction
         ]
  where
    pHiddenSpecFunctionNativeSpecFunction :: TermParser HiddenSpecFunctionL
    pHiddenSpecFunctionNativeSpecFunction =
      HiddenSpecFunctionNativeSpecFunction' <$> pSort @NativeSpecFunctionL "native_spec_function"
    pHiddenSpecFunctionUsualSpecFunction :: TermParser HiddenSpecFunctionL
    pHiddenSpecFunctionUsualSpecFunction =
      HiddenSpecFunctionUsualSpecFunction' <$> pSort @UsualSpecFunctionL "usual_spec_function"
    pHiddenSpecFunctionUninterpretedSpecFunction :: TermParser HiddenSpecFunctionL
    pHiddenSpecFunctionUninterpretedSpecFunction =
      HiddenSpecFunctionUninterpretedSpecFunction' <$> pSort @UninterpretedSpecFunctionL "uninterpreted_spec_function"

pNativeSpecFunction :: TermParser NativeSpecFunctionL
pNativeSpecFunction =
  NativeSpecFunction' <$> pSort @NativeTokL "native_tok" <*> pBetween (pSort @FunTokL "fun_tok") (pSort @SemicolonTokL ";_tok") (pHiddenSpecFunctionSignature)

pHiddenSpecFunctionSignature :: TermParser HiddenSpecFunctionSignatureL
pHiddenSpecFunctionSignature =
  HiddenSpecFunctionSignature' <$> pHiddenFunctionIdentifier <*> pMaybe (pSort @TypeParametersL "type_parameters") <*> pSort @FunctionParametersL "function_parameters" <*> pSort @RetTypeL "ret_type"

pUninterpretedSpecFunction :: TermParser UninterpretedSpecFunctionL
pUninterpretedSpecFunction =
  UninterpretedSpecFunction' <$> pBetween (pSort @FunTokL "fun_tok") (pSort @SemicolonTokL ";_tok") (pHiddenSpecFunctionSignature)

pUsualSpecFunction :: TermParser UsualSpecFunctionL
pUsualSpecFunction =
  UsualSpecFunction' <$> pSort @FunTokL "fun_tok" <*> pHiddenSpecFunctionSignature <*> pSort @BlockL "block"

pSpecBody :: TermParser SpecBodyL
pSpecBody =
  SpecBody' <$> pSort @LeftCurlyBracketTokL "{_tok" <*> pMany (pSort @UseDeclarationL "use_declaration") <*> pMany (pHiddenSpecBlockMemeber) <*> pSort @RightCurlyBracketTokL "}_tok"

pHiddenSpecBlockMemeber :: TermParser HiddenSpecBlockMemeberL
pHiddenSpecBlockMemeber =
  choice [ Megaparsec.try pHiddenSpecBlockMemeberSpecInvariant
         , Megaparsec.try pHiddenSpecBlockMemeberSpecFunction
         , Megaparsec.try pHiddenSpecBlockMemeberSpecCondition
         , Megaparsec.try pHiddenSpecBlockMemeberSpecInclude
         , Megaparsec.try pHiddenSpecBlockMemeberSpecApply
         , Megaparsec.try pHiddenSpecBlockMemeberSpecPragma
         , Megaparsec.try pHiddenSpecBlockMemeberSpecVariable
         , Megaparsec.try pHiddenSpecBlockMemeberSpecLet
         ]
  where
    pHiddenSpecBlockMemeberSpecInvariant :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecInvariant =
      HiddenSpecBlockMemeberSpecInvariant' <$> pSort @SpecInvariantL "spec_invariant"
    pHiddenSpecBlockMemeberSpecFunction :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecFunction =
      HiddenSpecBlockMemeberSpecFunction' <$> pHiddenSpecFunction
    pHiddenSpecBlockMemeberSpecCondition :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecCondition =
      HiddenSpecBlockMemeberSpecCondition' <$> pSort @SpecConditionL "spec_condition"
    pHiddenSpecBlockMemeberSpecInclude :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecInclude =
      HiddenSpecBlockMemeberSpecInclude' <$> pSort @SpecIncludeL "spec_include"
    pHiddenSpecBlockMemeberSpecApply :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecApply =
      HiddenSpecBlockMemeberSpecApply' <$> pSort @SpecApplyL "spec_apply"
    pHiddenSpecBlockMemeberSpecPragma :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecPragma =
      HiddenSpecBlockMemeberSpecPragma' <$> pSort @SpecPragmaL "spec_pragma"
    pHiddenSpecBlockMemeberSpecVariable :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecVariable =
      HiddenSpecBlockMemeberSpecVariable' <$> pSort @SpecVariableL "spec_variable"
    pHiddenSpecBlockMemeberSpecLet :: TermParser HiddenSpecBlockMemeberL
    pHiddenSpecBlockMemeberSpecLet =
      HiddenSpecBlockMemeberSpecLet' <$> pSort @SpecLetL "spec_let"

pSpecApply :: TermParser SpecApplyL
pSpecApply =
  SpecApply' <$> pBetween (pSort @ApplyTokL "apply_tok") (pSort @ToTokL "to_tok") (pHiddenExpression) <*> pSepBy1 (pSort @SpecApplyPatternL "spec_apply_pattern") (pSort @CommaTokL ",_tok") <*> pMaybe (pPair (pSort @ExceptTokL "except_tok") (pSepBy1 (pSort @SpecApplyPatternL "spec_apply_pattern") (pSort @CommaTokL ",_tok"))) <*> pSort @SemicolonTokL ";_tok"

pSpecApplyPattern :: TermParser SpecApplyPatternL
pSpecApplyPattern =
  SpecApplyPattern' <$> pMaybe (pSpecApplyPatternInternal0) <*> pSort @SpecApplyNamePatternL "spec_apply_name_pattern" <*> pMaybe (pSort @TypeParametersL "type_parameters")

pSpecApplyNamePattern :: TermParser SpecApplyNamePatternL
pSpecApplyNamePattern =
  SpecApplyNamePattern' <$> pContent

pSpecApplyPatternInternal0 :: TermParser SpecApplyPatternInternal0L
pSpecApplyPatternInternal0 =
  choice [ Megaparsec.try pSpecApplyPatternInternal0Public
         , Megaparsec.try pSpecApplyPatternInternal0Internal
         ]
  where
    pSpecApplyPatternInternal0Public :: TermParser SpecApplyPatternInternal0L
    pSpecApplyPatternInternal0Public =
      SpecApplyPatternInternal0Public' <$> pSort @PublicTokL "public_tok"
    pSpecApplyPatternInternal0Internal :: TermParser SpecApplyPatternInternal0L
    pSpecApplyPatternInternal0Internal =
      SpecApplyPatternInternal0Internal' <$> pInternalTok

pSpecCondition :: TermParser SpecConditionL
pSpecCondition =
  choice [ Megaparsec.try pSpecConditionSpecCondition
         , Megaparsec.try pSpecConditionSpecAbortIf
         , Megaparsec.try pSpecConditionSpecAbortWithOrModifies
         ]
  where
    pSpecConditionSpecCondition :: TermParser SpecConditionL
    pSpecConditionSpecCondition =
      SpecConditionSpecCondition' <$> pHiddenSpecCondition
    pSpecConditionSpecAbortIf :: TermParser SpecConditionL
    pSpecConditionSpecAbortIf =
      SpecConditionSpecAbortIf' <$> pHiddenSpecAbortIf
    pSpecConditionSpecAbortWithOrModifies :: TermParser SpecConditionL
    pSpecConditionSpecAbortWithOrModifies =
      SpecConditionSpecAbortWithOrModifies' <$> pHiddenSpecAbortWithOrModifies

pHiddenSpecAbortIf :: TermParser HiddenSpecAbortIfL
pHiddenSpecAbortIf =
  HiddenSpecAbortIf' <$> pSort @AbortsIfTokL "aborts_if_tok" <*> pMaybe (pSort @ConditionPropertiesL "condition_properties") <*> pHiddenExpression <*> pMaybe (pPair (pSort @WithTokL "with_tok") (pHiddenExpression)) <*> pSort @SemicolonTokL ";_tok"

pConditionProperties :: TermParser ConditionPropertiesL
pConditionProperties =
  ConditionProperties' <$> pBetween (pSort @LeftSquareBracketTokL "[_tok") (pSort @RightSquareBracketTokL "]_tok") (pSepBy (pSort @SpecPropertyL "spec_property") (pSort @CommaTokL ",_tok"))

pSpecProperty :: TermParser SpecPropertyL
pSpecProperty =
  SpecProperty' <$> pSort @IdentifierL "identifier" <*> pMaybe (pPair (pSort @EqualsSignTokL "=_tok") (pHiddenLiteralValue))

pHiddenSpecAbortWithOrModifies :: TermParser HiddenSpecAbortWithOrModifiesL
pHiddenSpecAbortWithOrModifies =
  HiddenSpecAbortWithOrModifies' <$> pHiddenSpecAbortWithOrModifiesInternal0 <*> pMaybe (pSort @ConditionPropertiesL "condition_properties") <*> pSepBy1 (pHiddenExpression) (pSort @CommaTokL ",_tok") <*> pSort @SemicolonTokL ";_tok"

pHiddenSpecAbortWithOrModifiesInternal0 :: TermParser HiddenSpecAbortWithOrModifiesInternal0L
pHiddenSpecAbortWithOrModifiesInternal0 =
  choice [ Megaparsec.try pHiddenSpecAbortWithOrModifiesInternal0AbortsWith
         , Megaparsec.try pHiddenSpecAbortWithOrModifiesInternal0Modifies
         ]
  where
    pHiddenSpecAbortWithOrModifiesInternal0AbortsWith :: TermParser HiddenSpecAbortWithOrModifiesInternal0L
    pHiddenSpecAbortWithOrModifiesInternal0AbortsWith =
      HiddenSpecAbortWithOrModifiesInternal0AbortsWith' <$> pSort @AbortsWithTokL "aborts_with_tok"
    pHiddenSpecAbortWithOrModifiesInternal0Modifies :: TermParser HiddenSpecAbortWithOrModifiesInternal0L
    pHiddenSpecAbortWithOrModifiesInternal0Modifies =
      HiddenSpecAbortWithOrModifiesInternal0Modifies' <$> pSort @ModifiesTokL "modifies_tok"

pHiddenSpecCondition :: TermParser HiddenSpecConditionL
pHiddenSpecCondition =
  HiddenSpecCondition' <$> pHiddenSpecConditionInternal0 <*> pMaybe (pSort @ConditionPropertiesL "condition_properties") <*> pHiddenExpression <*> pSort @SemicolonTokL ";_tok"

pHiddenSpecConditionInternal0 :: TermParser HiddenSpecConditionInternal0L
pHiddenSpecConditionInternal0 =
  choice [ Megaparsec.try pHiddenSpecConditionInternal0Kind
         , Megaparsec.try pHiddenSpecConditionInternal02
         ]
  where
    pHiddenSpecConditionInternal0Kind :: TermParser HiddenSpecConditionInternal0L
    pHiddenSpecConditionInternal0Kind =
      HiddenSpecConditionInternal0Kind' <$> pHiddenSpecConditionKind
    pHiddenSpecConditionInternal02 :: TermParser HiddenSpecConditionInternal0L
    pHiddenSpecConditionInternal02 =
      HiddenSpecConditionInternal02' <$> pSort @RequiresTokL "requires_tok" <*> pMaybe (pSort @ModuleTokL "module_tok")

pHiddenSpecConditionKind :: TermParser HiddenSpecConditionKindL
pHiddenSpecConditionKind =
  choice [ Megaparsec.try pHiddenSpecConditionKindAssert
         , Megaparsec.try pHiddenSpecConditionKindAssume
         , Megaparsec.try pHiddenSpecConditionKindDecreases
         , Megaparsec.try pHiddenSpecConditionKindEnsures
         , Megaparsec.try pHiddenSpecConditionKindSucceedsIf
         ]
  where
    pHiddenSpecConditionKindAssert :: TermParser HiddenSpecConditionKindL
    pHiddenSpecConditionKindAssert =
      HiddenSpecConditionKindAssert' <$> pSort @AssertTokL "assert_tok"
    pHiddenSpecConditionKindAssume :: TermParser HiddenSpecConditionKindL
    pHiddenSpecConditionKindAssume =
      HiddenSpecConditionKindAssume' <$> pSort @AssumeTokL "assume_tok"
    pHiddenSpecConditionKindDecreases :: TermParser HiddenSpecConditionKindL
    pHiddenSpecConditionKindDecreases =
      HiddenSpecConditionKindDecreases' <$> pSort @DecreasesTokL "decreases_tok"
    pHiddenSpecConditionKindEnsures :: TermParser HiddenSpecConditionKindL
    pHiddenSpecConditionKindEnsures =
      HiddenSpecConditionKindEnsures' <$> pSort @EnsuresTokL "ensures_tok"
    pHiddenSpecConditionKindSucceedsIf :: TermParser HiddenSpecConditionKindL
    pHiddenSpecConditionKindSucceedsIf =
      HiddenSpecConditionKindSucceedsIf' <$> pSort @SucceedsIfTokL "succeeds_if_tok"

pSpecInclude :: TermParser SpecIncludeL
pSpecInclude =
  SpecInclude' <$> pBetween (pSort @IncludeTokL "include_tok") (pSort @SemicolonTokL ";_tok") (pHiddenExpression)

pSpecInvariant :: TermParser SpecInvariantL
pSpecInvariant =
  SpecInvariant' <$> pSort @InvariantTokL "invariant_tok" <*> pMaybe (pSpecInvariantInternal0) <*> pMaybe (pSort @ConditionPropertiesL "condition_properties") <*> pHiddenExpression <*> pSort @SemicolonTokL ";_tok"

pSpecInvariantInternal0 :: TermParser SpecInvariantInternal0L
pSpecInvariantInternal0 =
  choice [ Megaparsec.try pSpecInvariantInternal0Update
         , Megaparsec.try pSpecInvariantInternal0Pack
         , Megaparsec.try pSpecInvariantInternal0Unpack
         , Megaparsec.try pSpecInvariantInternal0Module
         ]
  where
    pSpecInvariantInternal0Update :: TermParser SpecInvariantInternal0L
    pSpecInvariantInternal0Update =
      SpecInvariantInternal0Update' <$> pSort @UpdateTokL "update_tok"
    pSpecInvariantInternal0Pack :: TermParser SpecInvariantInternal0L
    pSpecInvariantInternal0Pack =
      SpecInvariantInternal0Pack' <$> pSort @PackTokL "pack_tok"
    pSpecInvariantInternal0Unpack :: TermParser SpecInvariantInternal0L
    pSpecInvariantInternal0Unpack =
      SpecInvariantInternal0Unpack' <$> pSort @UnpackTokL "unpack_tok"
    pSpecInvariantInternal0Module :: TermParser SpecInvariantInternal0L
    pSpecInvariantInternal0Module =
      SpecInvariantInternal0Module' <$> pSort @ModuleTokL "module_tok"

pSpecLet :: TermParser SpecLetL
pSpecLet =
  SpecLet' <$> pSort @LetTokL "let_tok" <*> pMaybe (pSort @PostTokL "post_tok") <*> pSort @IdentifierL "identifier" <*> pBetween (pSort @EqualsSignTokL "=_tok") (pSort @SemicolonTokL ";_tok") (pHiddenExpression)

pSpecPragma :: TermParser SpecPragmaL
pSpecPragma =
  SpecPragma' <$> pBetween (pSort @PragmaTokL "pragma_tok") (pSort @SemicolonTokL ";_tok") (pSepBy (pSort @SpecPropertyL "spec_property") (pSort @CommaTokL ",_tok"))

pSpecVariable :: TermParser SpecVariableL
pSpecVariable =
  SpecVariable' <$> pMaybe (pSpecVariableInternal0) <*> pSort @IdentifierL "identifier" <*> pMaybe (pSort @TypeParametersL "type_parameters") <*> pBetween (pSort @ColonTokL ":_tok") (pSort @SemicolonTokL ";_tok") (pHiddenType)

pSpecVariableInternal0 :: TermParser SpecVariableInternal0L
pSpecVariableInternal0 =
  choice [ Megaparsec.try pSpecVariableInternal0Global
         , Megaparsec.try pSpecVariableInternal0Local
         ]
  where
    pSpecVariableInternal0Global :: TermParser SpecVariableInternal0L
    pSpecVariableInternal0Global =
      SpecVariableInternal0Global' <$> pSort @GlobalTokL "global_tok"
    pSpecVariableInternal0Local :: TermParser SpecVariableInternal0L
    pSpecVariableInternal0Local =
      SpecVariableInternal0Local' <$> pSort @LocalTokL "local_tok"

pUseDeclaration :: TermParser UseDeclarationL
pUseDeclaration =
  UseDeclaration' <$> pMaybe (pSort @PublicTokL "public_tok") <*> pBetween (pSort @UseTokL "use_tok") (pSort @SemicolonTokL ";_tok") (pUseDeclarationInternal0)

pUseDeclarationInternal0 :: TermParser UseDeclarationInternal0L
pUseDeclarationInternal0 =
  choice [ Megaparsec.try pUseDeclarationInternal0UseFun
         , Megaparsec.try pUseDeclarationInternal0UseModule
         , Megaparsec.try pUseDeclarationInternal0UseModuleMember
         , Megaparsec.try pUseDeclarationInternal0UseModuleMembers
         ]
  where
    pUseDeclarationInternal0UseFun :: TermParser UseDeclarationInternal0L
    pUseDeclarationInternal0UseFun =
      UseDeclarationInternal0UseFun' <$> pSort @UseFunL "use_fun"
    pUseDeclarationInternal0UseModule :: TermParser UseDeclarationInternal0L
    pUseDeclarationInternal0UseModule =
      UseDeclarationInternal0UseModule' <$> pSort @UseModuleL "use_module"
    pUseDeclarationInternal0UseModuleMember :: TermParser UseDeclarationInternal0L
    pUseDeclarationInternal0UseModuleMember =
      UseDeclarationInternal0UseModuleMember' <$> pSort @UseModuleMemberL "use_module_member"
    pUseDeclarationInternal0UseModuleMembers :: TermParser UseDeclarationInternal0L
    pUseDeclarationInternal0UseModuleMembers =
      UseDeclarationInternal0UseModuleMembers' <$> pSort @UseModuleMembersL "use_module_members"

pUseFun :: TermParser UseFunL
pUseFun =
  UseFun' <$> pBetween (pSort @FunTokL "fun_tok") (pSort @AsTokL "as_tok") (pSort @ModuleAccessL "module_access") <*> pPair (pPair (pSort @ModuleAccessL "module_access") (pSort @FullStopTokL "._tok")) (pHiddenFunctionIdentifier)

pUseModule :: TermParser UseModuleL
pUseModule =
  UseModule' <$> pSort @ModuleIdentityL "module_identity" <*> pMaybe (pPair (pSort @AsTokL "as_tok") (pHiddenModuleIdentifier))

pUseModuleMember :: TermParser UseModuleMemberL
pUseModuleMember =
  UseModuleMember' <$> pSort @ModuleIdentityL "module_identity" <*> pSort @ColonColonTokL "::_tok" <*> pSort @UseMemberL "use_member"

pUseMember :: TermParser UseMemberL
pUseMember =
  choice [ Megaparsec.try pUseMember1
         , Megaparsec.try pUseMember2
         , Megaparsec.try pUseMember3
         ]
  where
    pUseMember1 :: TermParser UseMemberL
    pUseMember1 =
      UseMember1' <$> pSort @IdentifierL "identifier" <*> pSort @ColonColonTokL "::_tok" <*> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy1 (pSort @UseMemberL "use_member") (pSort @CommaTokL ",_tok"))
    pUseMember2 :: TermParser UseMemberL
    pUseMember2 =
      UseMember2' <$> pSort @IdentifierL "identifier" <*> pSort @ColonColonTokL "::_tok" <*> pSort @IdentifierL "identifier" <*> pMaybe (pPair (pSort @AsTokL "as_tok") (pSort @IdentifierL "identifier"))
    pUseMember3 :: TermParser UseMemberL
    pUseMember3 =
      UseMember3' <$> pSort @IdentifierL "identifier" <*> pMaybe (pPair (pSort @AsTokL "as_tok") (pSort @IdentifierL "identifier"))

pUseModuleMembers :: TermParser UseModuleMembersL
pUseModuleMembers =
  choice [ Megaparsec.try pUseModuleMembers1
         , Megaparsec.try pUseModuleMembers2
         ]
  where
    pUseModuleMembers1 :: TermParser UseModuleMembersL
    pUseModuleMembers1 =
      UseModuleMembers1' <$> pModuleIdentityInternal0 <*> pSort @ColonColonTokL "::_tok" <*> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy1 (pSort @UseMemberL "use_member") (pSort @CommaTokL ",_tok"))
    pUseModuleMembers2 :: TermParser UseModuleMembersL
    pUseModuleMembers2 =
      UseModuleMembers2' <$> pSort @ModuleIdentityL "module_identity" <*> pSort @ColonColonTokL "::_tok" <*> pBetween (pSort @LeftCurlyBracketTokL "{_tok") (pSort @RightCurlyBracketTokL "}_tok") (pSepBy1 (pSort @UseMemberL "use_member") (pSort @CommaTokL ",_tok"))

pUnitExpression :: TermParser UnitExpressionL
pUnitExpression =
  UnitExpression' <$> pSort @LeftParenthesisTokL "(_tok" <*> pSort @RightParenthesisTokL ")_tok"

pVectorExpression :: TermParser VectorExpressionL
pVectorExpression =
  VectorExpression' <$> pVectorExpressionInternal0 <*> pSepBy (pHiddenExpression) (pSort @CommaTokL ",_tok") <*> pSort @RightSquareBracketTokL "]_tok"

pVectorExpressionInternal0 :: TermParser VectorExpressionInternal0L
pVectorExpressionInternal0 =
  choice [ Megaparsec.try pVectorExpressionInternal0VectorLeftSquareBracket
         , Megaparsec.try pVectorExpressionInternal02
         ]
  where
    pVectorExpressionInternal0VectorLeftSquareBracket :: TermParser VectorExpressionInternal0L
    pVectorExpressionInternal0VectorLeftSquareBracket =
      VectorExpressionInternal0VectorLeftSquareBracket' <$> pSort @VectorLeftSquareBracketTokL "vector[_tok"
    pVectorExpressionInternal02 :: TermParser VectorExpressionInternal0L
    pVectorExpressionInternal02 =
      VectorExpressionInternal02' <$> pBetween (pSort @VectorLessThanSignTokL "vector<_tok") (pSort @GreaterThanSignTokL ">_tok") (pSepBy1 (pHiddenType) (pSort @CommaTokL ",_tok")) <*> pSort @LeftSquareBracketTokL "[_tok"

pBorrowExpression :: TermParser BorrowExpressionL
pBorrowExpression =
  BorrowExpression' <$> pPair (pHiddenReference) (pHiddenExpression)

pDereferenceExpression :: TermParser DereferenceExpressionL
pDereferenceExpression =
  DereferenceExpression' <$> pPair (pSort @AsteriskTokL "*_tok") (pHiddenExpression)

pMoveOrCopyExpression :: TermParser MoveOrCopyExpressionL
pMoveOrCopyExpression =
  MoveOrCopyExpression' <$> pPair (pMoveOrCopyExpressionInternal0) (pHiddenExpression)

pMoveOrCopyExpressionInternal0 :: TermParser MoveOrCopyExpressionInternal0L
pMoveOrCopyExpressionInternal0 =
  choice [ Megaparsec.try pMoveOrCopyExpressionInternal0Move
         , Megaparsec.try pMoveOrCopyExpressionInternal0Copy
         ]
  where
    pMoveOrCopyExpressionInternal0Move :: TermParser MoveOrCopyExpressionInternal0L
    pMoveOrCopyExpressionInternal0Move =
      MoveOrCopyExpressionInternal0Move' <$> pSort @MoveTokL "move_tok"
    pMoveOrCopyExpressionInternal0Copy :: TermParser MoveOrCopyExpressionInternal0L
    pMoveOrCopyExpressionInternal0Copy =
      MoveOrCopyExpressionInternal0Copy' <$> pSort @CopyTokL "copy_tok"

pUnaryExpression :: TermParser UnaryExpressionL
pUnaryExpression =
  UnaryExpression' <$> pSort @UnaryOpL "unary_op" <*> pHiddenExpression

pUnaryOp :: TermParser UnaryOpL
pUnaryOp =
  UnaryOp' <$> pSort @ExclamationMarkTokL "!_tok"

pAbortExpression :: TermParser AbortExpressionL
pAbortExpression =
  AbortExpression' <$> pSort @AbortTokL "abort_tok" <*> pMaybe (pHiddenExpression)

pAssignExpression :: TermParser AssignExpressionL
pAssignExpression =
  AssignExpression' <$> pPair (pPair (pHiddenUnaryExpression) (pSort @EqualsSignTokL "=_tok")) (pHiddenExpression)

pBinaryExpression :: TermParser BinaryExpressionL
pBinaryExpression =
  choice [ Megaparsec.try pBinaryExpression1
         , Megaparsec.try pBinaryExpression2
         , Megaparsec.try pBinaryExpression3
         , Megaparsec.try pBinaryExpression4
         , Megaparsec.try pBinaryExpression5
         , Megaparsec.try pBinaryExpression6
         , Megaparsec.try pBinaryExpression7
         , Megaparsec.try pBinaryExpression8
         , Megaparsec.try pBinaryExpression9
         , Megaparsec.try pBinaryExpression10
         , Megaparsec.try pBinaryExpression11
         , Megaparsec.try pBinaryExpression12
         , Megaparsec.try pBinaryExpression13
         , Megaparsec.try pBinaryExpression14
         , Megaparsec.try pBinaryExpression15
         , Megaparsec.try pBinaryExpression16
         , Megaparsec.try pBinaryExpression17
         , Megaparsec.try pBinaryExpression18
         , Megaparsec.try pBinaryExpression19
         , Megaparsec.try pBinaryExpression20
         ]
  where
    pBinaryExpression1 :: TermParser BinaryExpressionL
    pBinaryExpression1 =
      BinaryExpression1' <$> pHiddenExpression <*> pSort @EqualsSignEqualsSignGreaterThanSignTokL "==>_tok" <*> pHiddenExpression
    pBinaryExpression2 :: TermParser BinaryExpressionL
    pBinaryExpression2 =
      BinaryExpression2' <$> pHiddenExpression <*> pSort @VerticalLineVerticalLineTokL "||_tok" <*> pHiddenExpression
    pBinaryExpression3 :: TermParser BinaryExpressionL
    pBinaryExpression3 =
      BinaryExpression3' <$> pHiddenExpression <*> pSort @AmpersandAmpersandTokL "&&_tok" <*> pHiddenExpression
    pBinaryExpression4 :: TermParser BinaryExpressionL
    pBinaryExpression4 =
      BinaryExpression4' <$> pHiddenExpression <*> pSort @EqualsSignEqualsSignTokL "==_tok" <*> pHiddenExpression
    pBinaryExpression5 :: TermParser BinaryExpressionL
    pBinaryExpression5 =
      BinaryExpression5' <$> pHiddenExpression <*> pSort @ExclamationMarkEqualsSignTokL "!=_tok" <*> pHiddenExpression
    pBinaryExpression6 :: TermParser BinaryExpressionL
    pBinaryExpression6 =
      BinaryExpression6' <$> pHiddenExpression <*> pSort @LessThanSignTokL "<_tok" <*> pHiddenExpression
    pBinaryExpression7 :: TermParser BinaryExpressionL
    pBinaryExpression7 =
      BinaryExpression7' <$> pHiddenExpression <*> pSort @GreaterThanSignTokL ">_tok" <*> pHiddenExpression
    pBinaryExpression8 :: TermParser BinaryExpressionL
    pBinaryExpression8 =
      BinaryExpression8' <$> pHiddenExpression <*> pSort @LessThanSignEqualsSignTokL "<=_tok" <*> pHiddenExpression
    pBinaryExpression9 :: TermParser BinaryExpressionL
    pBinaryExpression9 =
      BinaryExpression9' <$> pHiddenExpression <*> pSort @GreaterThanSignEqualsSignTokL ">=_tok" <*> pHiddenExpression
    pBinaryExpression10 :: TermParser BinaryExpressionL
    pBinaryExpression10 =
      BinaryExpression10' <$> pHiddenExpression <*> pSort @FullStopFullStopTokL ".._tok" <*> pHiddenExpression
    pBinaryExpression11 :: TermParser BinaryExpressionL
    pBinaryExpression11 =
      BinaryExpression11' <$> pHiddenExpression <*> pSort @VerticalLineTokL "|_tok" <*> pHiddenExpression
    pBinaryExpression12 :: TermParser BinaryExpressionL
    pBinaryExpression12 =
      BinaryExpression12' <$> pHiddenExpression <*> pSort @CircumflexAccentTokL "^_tok" <*> pHiddenExpression
    pBinaryExpression13 :: TermParser BinaryExpressionL
    pBinaryExpression13 =
      BinaryExpression13' <$> pHiddenExpression <*> pSort @AmpersandTokL "&_tok" <*> pHiddenExpression
    pBinaryExpression14 :: TermParser BinaryExpressionL
    pBinaryExpression14 =
      BinaryExpression14' <$> pHiddenExpression <*> pSort @LessThanSignLessThanSignTokL "<<_tok" <*> pHiddenExpression
    pBinaryExpression15 :: TermParser BinaryExpressionL
    pBinaryExpression15 =
      BinaryExpression15' <$> pHiddenExpression <*> pSort @GreaterThanSignGreaterThanSignTokL ">>_tok" <*> pHiddenExpression
    pBinaryExpression16 :: TermParser BinaryExpressionL
    pBinaryExpression16 =
      BinaryExpression16' <$> pHiddenExpression <*> pSort @PlusSignTokL "+_tok" <*> pHiddenExpression
    pBinaryExpression17 :: TermParser BinaryExpressionL
    pBinaryExpression17 =
      BinaryExpression17' <$> pHiddenExpression <*> pSort @HyphenMinusTokL "-_tok" <*> pHiddenExpression
    pBinaryExpression18 :: TermParser BinaryExpressionL
    pBinaryExpression18 =
      BinaryExpression18' <$> pHiddenExpression <*> pSort @AsteriskTokL "*_tok" <*> pHiddenExpression
    pBinaryExpression19 :: TermParser BinaryExpressionL
    pBinaryExpression19 =
      BinaryExpression19' <$> pHiddenExpression <*> pSort @SolidusTokL "/_tok" <*> pHiddenExpression
    pBinaryExpression20 :: TermParser BinaryExpressionL
    pBinaryExpression20 =
      BinaryExpression20' <$> pHiddenExpression <*> pSort @PercentSignTokL "%_tok" <*> pHiddenExpression

pCastExpression :: TermParser CastExpressionL
pCastExpression =
  CastExpression' <$> pPair (pPair (pHiddenExpression) (pSort @AsTokL "as_tok")) (pHiddenType)

pIdentifiedExpression :: TermParser IdentifiedExpressionL
pIdentifiedExpression =
  IdentifiedExpression' <$> pSort @BlockIdentifierL "block_identifier" <*> pHiddenExpression

pBlockIdentifier :: TermParser BlockIdentifierL
pBlockIdentifier =
  BlockIdentifier' <$> pSort @LabelL "label" <*> pSort @ColonTokL ":_tok"

pLambdaExpression :: TermParser LambdaExpressionL
pLambdaExpression =
  LambdaExpression' <$> pSort @LambdaBindingsL "lambda_bindings" <*> pMaybe (pPair (pSort @HyphenMinusGreaterThanSignTokL "->_tok") (pHiddenType)) <*> pHiddenExpression

pLambdaBindings :: TermParser LambdaBindingsL
pLambdaBindings =
  LambdaBindings' <$> pBetween (pSort @VerticalLineTokL "|_tok") (pSort @VerticalLineTokL "|_tok") (pSepBy (pSort @LambdaBindingL "lambda_binding") (pSort @CommaTokL ",_tok"))

pLambdaBinding :: TermParser LambdaBindingL
pLambdaBinding =
  choice [ Megaparsec.try pLambdaBindingCommaBindList
         , Megaparsec.try pLambdaBindingBind
         , Megaparsec.try pLambdaBinding3
         ]
  where
    pLambdaBindingCommaBindList :: TermParser LambdaBindingL
    pLambdaBindingCommaBindList =
      LambdaBindingCommaBindList' <$> pSort @CommaBindListL "comma_bind_list"
    pLambdaBindingBind :: TermParser LambdaBindingL
    pLambdaBindingBind =
      LambdaBindingBind' <$> pHiddenBind
    pLambdaBinding3 :: TermParser LambdaBindingL
    pLambdaBinding3 =
      LambdaBinding3' <$> pHiddenBind <*> pMaybe (pPair (pSort @ColonTokL ":_tok") (pHiddenType))

pLoopExpression :: TermParser LoopExpressionL
pLoopExpression =
  LoopExpression' <$> pSort @LoopTokL "loop_tok" <*> pHiddenExpression

pQuantifierExpression :: TermParser QuantifierExpressionL
pQuantifierExpression =
  QuantifierExpression' <$> pPair (pPair (pPair (pPair (pQuantifierExpressionInternal0) (pSort @QuantifierBindingsL "quantifier_bindings")) (pMaybe (pPair (pSort @WhereTokL "where_tok") (pHiddenExpression)))) (pSort @ColonTokL ":_tok")) (pHiddenExpression)

pQuantifierBindings :: TermParser QuantifierBindingsL
pQuantifierBindings =
  QuantifierBindings' <$> pSepBy1 (pSort @QuantifierBindingL "quantifier_binding") (pSort @CommaTokL ",_tok")

pQuantifierBinding :: TermParser QuantifierBindingL
pQuantifierBinding =
  choice [ Megaparsec.try pQuantifierBinding1
         , Megaparsec.try pQuantifierBinding2
         ]
  where
    pQuantifierBinding1 :: TermParser QuantifierBindingL
    pQuantifierBinding1 =
      QuantifierBinding1' <$> pSort @IdentifierL "identifier" <*> pSort @ColonTokL ":_tok" <*> pHiddenType
    pQuantifierBinding2 :: TermParser QuantifierBindingL
    pQuantifierBinding2 =
      QuantifierBinding2' <$> pSort @IdentifierL "identifier" <*> pSort @InTokL "in_tok" <*> pHiddenExpression

pQuantifierExpressionInternal0 :: TermParser QuantifierExpressionInternal0L
pQuantifierExpressionInternal0 =
  choice [ Megaparsec.try pQuantifierExpressionInternal0Forall
         , Megaparsec.try pQuantifierExpressionInternal0Exists
         ]
  where
    pQuantifierExpressionInternal0Forall :: TermParser QuantifierExpressionInternal0L
    pQuantifierExpressionInternal0Forall =
      QuantifierExpressionInternal0Forall' <$> pHiddenForall
    pQuantifierExpressionInternal0Exists :: TermParser QuantifierExpressionInternal0L
    pQuantifierExpressionInternal0Exists =
      QuantifierExpressionInternal0Exists' <$> pHiddenExists

pReturnExpression :: TermParser ReturnExpressionL
pReturnExpression =
  choice [ Megaparsec.try pReturnExpression1
         , Megaparsec.try pReturnExpression2
         ]
  where
    pReturnExpression1 :: TermParser ReturnExpressionL
    pReturnExpression1 =
      ReturnExpression1' <$> pSort @ReturnTokL "return_tok" <*> pMaybe (pSort @LabelL "label") <*> pHiddenExpression
    pReturnExpression2 :: TermParser ReturnExpressionL
    pReturnExpression2 =
      ReturnExpression2' <$> pSort @ReturnTokL "return_tok" <*> pMaybe (pSort @LabelL "label")

pWhileExpression :: TermParser WhileExpressionL
pWhileExpression =
  WhileExpression' <$> pSort @WhileTokL "while_tok" <*> pBetween (pSort @LeftParenthesisTokL "(_tok") (pSort @RightParenthesisTokL ")_tok") (pHiddenExpression) <*> pHiddenExpression

pBlockItem :: TermParser BlockItemL
pBlockItem =
  BlockItem' <$> pBlockItemInternal0 <*> pSort @SemicolonTokL ";_tok"

pBlockItemInternal0 :: TermParser BlockItemInternal0L
pBlockItemInternal0 =
  choice [ Megaparsec.try pBlockItemInternal0Expression
         , Megaparsec.try pBlockItemInternal0LetStatement
         ]
  where
    pBlockItemInternal0Expression :: TermParser BlockItemInternal0L
    pBlockItemInternal0Expression =
      BlockItemInternal0Expression' <$> pHiddenExpression
    pBlockItemInternal0LetStatement :: TermParser BlockItemInternal0L
    pBlockItemInternal0LetStatement =
      BlockItemInternal0LetStatement' <$> pSort @LetStatementL "let_statement"

pLetStatement :: TermParser LetStatementL
pLetStatement =
  LetStatement' <$> pSort @LetTokL "let_tok" <*> pSort @BindListL "bind_list" <*> pMaybe (pPair (pSort @ColonTokL ":_tok") (pHiddenType)) <*> pMaybe (pPair (pSort @EqualsSignTokL "=_tok") (pHiddenExpression))

pMacroFunctionDefinition :: TermParser MacroFunctionDefinitionL
pMacroFunctionDefinition =
  MacroFunctionDefinition' <$> pMaybe (pSort @ModifierL "modifier") <*> pSort @MacroTokL "macro_tok" <*> pHiddenMacroSignature <*> pSort @BlockL "block"

pHiddenMacroSignature :: TermParser HiddenMacroSignatureL
pHiddenMacroSignature =
  HiddenMacroSignature' <$> pMaybe (pSort @ModifierL "modifier") <*> pSort @FunTokL "fun_tok" <*> pHiddenFunctionIdentifier <*> pMaybe (pSort @TypeParametersL "type_parameters") <*> pSort @FunctionParametersL "function_parameters" <*> pMaybe (pSort @RetTypeL "ret_type")

pNativeFunctionDefinition :: TermParser NativeFunctionDefinitionL
pNativeFunctionDefinition =
  NativeFunctionDefinition' <$> pHiddenFunctionSignature <*> pSort @SemicolonTokL ";_tok"

pHiddenStructItem :: TermParser HiddenStructItemL
pHiddenStructItem =
  choice [ Megaparsec.try pHiddenStructItemNativeStructDefinition
         , Megaparsec.try pHiddenStructItemStructDefinition
         ]
  where
    pHiddenStructItemNativeStructDefinition :: TermParser HiddenStructItemL
    pHiddenStructItemNativeStructDefinition =
      HiddenStructItemNativeStructDefinition' <$> pSort @NativeStructDefinitionL "native_struct_definition"
    pHiddenStructItemStructDefinition :: TermParser HiddenStructItemL
    pHiddenStructItemStructDefinition =
      HiddenStructItemStructDefinition' <$> pSort @StructDefinitionL "struct_definition"

pNativeStructDefinition :: TermParser NativeStructDefinitionL
pNativeStructDefinition =
  NativeStructDefinition' <$> pMaybe (pSort @PublicTokL "public_tok") <*> pBetween (pSort @NativeTokL "native_tok") (pSort @SemicolonTokL ";_tok") (pHiddenStructSignature)

pHiddenStructSignature :: TermParser HiddenStructSignatureL
pHiddenStructSignature =
  HiddenStructSignature' <$> pSort @StructTokL "struct_tok" <*> pHiddenStructIdentifier <*> pMaybe (pSort @TypeParametersL "type_parameters") <*> pMaybe (pSort @AbilityDeclsL "ability_decls")

pStructDefinition :: TermParser StructDefinitionL
pStructDefinition =
  StructDefinition' <$> pMaybe (pSort @PublicTokL "public_tok") <*> pHiddenStructSignature <*> pSort @DatatypeFieldsL "datatype_fields" <*> pMaybe (pSort @PostfixAbilityDeclsL "postfix_ability_decls")

pConstant :: TermParser ConstantL
pConstant =
  Constant' <$> pBetween (pSort @ConstTokL "const_tok") (pSort @ColonTokL ":_tok") (pSort @IdentifierL "identifier") <*> pHiddenType <*> pBetween (pSort @EqualsSignTokL "=_tok") (pSort @SemicolonTokL ";_tok") (pHiddenExpression)

pFriendDeclaration :: TermParser FriendDeclarationL
pFriendDeclaration =
  FriendDeclaration' <$> pBetween (pSort @FriendTokL "friend_tok") (pSort @SemicolonTokL ";_tok") (pSort @FriendAccessL "friend_access")

pFriendAccess :: TermParser FriendAccessL
pFriendAccess =
  choice [ Megaparsec.try pFriendAccessLocalModule
         , Megaparsec.try pFriendAccessFullyQualifiedModule
         ]
  where
    pFriendAccessLocalModule :: TermParser FriendAccessL
    pFriendAccessLocalModule =
      FriendAccessLocalModule' <$> pSort @IdentifierL "identifier"
    pFriendAccessFullyQualifiedModule :: TermParser FriendAccessL
    pFriendAccessFullyQualifiedModule =
      FriendAccessFullyQualifiedModule' <$> pSort @ModuleIdentityL "module_identity"

pModuleExtensionDefinition :: TermParser ModuleExtensionDefinitionL
pModuleExtensionDefinition =
  ModuleExtensionDefinition' <$> pSort @ExtendTokL "extend_tok" <*> pSort @ModuleDefinitionL "module_definition"

--------------------------------------------------------------------------------
-- Parse Table
--------------------------------------------------------------------------------

newtype ParseTable = SymbolTable {unParseTable :: IntMap SomeTermParser}

symbolMap :: Map String SomeTermParser
symbolMap = Map.fromList
    [ ("source_file", E <$> pSourceFile)
    , ("source_file_internal0", E <$> pSourceFileInternal0)
    , ("module_definition", E <$> pModuleDefinition)
    , ("module_body", E <$> pModuleBody)
    , ("module_body_internal0", E <$> pModuleBodyInternal0)
    , ("module_body_internal1", E <$> pModuleBodyInternal1)
    , ("_enum_item", E <$> pHiddenEnumItem)
    , ("enum_definition", E <$> pEnumDefinition)
    , ("_enum_signature", E <$> pHiddenEnumSignature)
    , ("_enum_identifier", E <$> pHiddenEnumIdentifier)
    , ("identifier", E <$> pIdentifier)
    , ("ability_decls", E <$> pAbilityDecls)
    , ("ability", E <$> pAbility)
    , ("type_parameters", E <$> pTypeParameters)
    , ("type_parameter", E <$> pTypeParameter)
    , ("_type_parameter_identifier", E <$> pHiddenTypeParameterIdentifier)
    , ("enum_variants", E <$> pEnumVariants)
    , ("variant", E <$> pVariant)
    , ("_variant_identifier", E <$> pHiddenVariantIdentifier)
    , ("datatype_fields", E <$> pDatatypeFields)
    , ("named_fields", E <$> pNamedFields)
    , ("field_annotation", E <$> pFieldAnnotation)
    , ("_field_identifier", E <$> pHiddenFieldIdentifier)
    , ("_type", E <$> pHiddenType)
    , ("apply_type", E <$> pApplyType)
    , ("module_access", E <$> pModuleAccess)
    , ("_module_identifier", E <$> pHiddenModuleIdentifier)
    , ("_reserved_identifier", E <$> pHiddenReservedIdentifier)
    , ("_exists", E <$> pHiddenExists)
    , ("_forall", E <$> pHiddenForall)
    , ("module_identity", E <$> pModuleIdentity)
    , ("module_identity_internal0", E <$> pModuleIdentityInternal0)
    , ("num_literal", E <$> pNumLiteral)
    , ("num_literal_internal0", E <$> pNumLiteralInternal0)
    , ("type_arguments", E <$> pTypeArguments)
    , ("function_type", E <$> pFunctionType)
    , ("function_type_parameters", E <$> pFunctionTypeParameters)
    , ("primitive_type", E <$> pPrimitiveType)
    , ("ref_type", E <$> pRefType)
    , ("_reference", E <$> pHiddenReference)
    , ("imm_ref", E <$> pImmRef)
    , ("mut_ref", E <$> pMutRef)
    , ("tuple_type", E <$> pTupleType)
    , ("positional_fields", E <$> pPositionalFields)
    , ("postfix_ability_decls", E <$> pPostfixAbilityDecls)
    , ("_function_item", E <$> pHiddenFunctionItem)
    , ("function_definition", E <$> pFunctionDefinition)
    , ("_function_signature", E <$> pHiddenFunctionSignature)
    , ("_function_identifier", E <$> pHiddenFunctionIdentifier)
    , ("function_parameters", E <$> pFunctionParameters)
    , ("function_parameters_internal0", E <$> pFunctionParametersInternal0)
    , ("function_parameter", E <$> pFunctionParameter)
    , ("function_parameter_internal0", E <$> pFunctionParameterInternal0)
    , ("_variable_identifier", E <$> pHiddenVariableIdentifier)
    , ("mut_function_parameter", E <$> pMutFunctionParameter)
    , ("modifier", E <$> pModifier)
    , ("modifier_internal0", E <$> pModifierInternal0)
    , ("ret_type", E <$> pRetType)
    , ("block", E <$> pBlock)
    , ("_expression", E <$> pHiddenExpression)
    , ("_unary_expression", E <$> pHiddenUnaryExpression)
    , ("_unary_expression_internal0", E <$> pHiddenUnaryExpressionInternal0)
    , ("_expression_term", E <$> pHiddenExpressionTerm)
    , ("_literal_value", E <$> pHiddenLiteralValue)
    , ("address_literal", E <$> pAddressLiteral)
    , ("bool_literal", E <$> pBoolLiteral)
    , ("byte_string_literal", E <$> pByteStringLiteral)
    , ("hex_string_literal", E <$> pHexStringLiteral)
    , ("string_literal", E <$> pStringLiteral)
    , ("annotation_expression", E <$> pAnnotationExpression)
    , ("break_expression", E <$> pBreakExpression)
    , ("label", E <$> pLabel)
    , ("call_expression", E <$> pCallExpression)
    , ("arg_list", E <$> pArgList)
    , ("name_expression", E <$> pNameExpression)
    , ("continue_expression", E <$> pContinueExpression)
    , ("dot_expression", E <$> pDotExpression)
    , ("expression_list", E <$> pExpressionList)
    , ("if_expression", E <$> pIfExpression)
    , ("index_expression", E <$> pIndexExpression)
    , ("macro_call_expression", E <$> pMacroCallExpression)
    , ("macro_module_access", E <$> pMacroModuleAccess)
    , ("match_expression", E <$> pMatchExpression)
    , ("_match_body", E <$> pHiddenMatchBody)
    , ("match_arm", E <$> pMatchArm)
    , ("bind_list", E <$> pBindList)
    , ("_bind", E <$> pHiddenBind)
    , ("_bind_internal0", E <$> pHiddenBindInternal0)
    , ("mut_bind_var", E <$> pMutBindVar)
    , ("at_bind", E <$> pAtBind)
    , ("bind_unpack", E <$> pBindUnpack)
    , ("bind_fields", E <$> pBindFields)
    , ("bind_named_fields", E <$> pBindNamedFields)
    , ("bind_named_fields_internal0", E <$> pBindNamedFieldsInternal0)
    , ("bind_field", E <$> pBindField)
    , ("_spread_operator", E <$> pHiddenSpreadOperator)
    , ("mut_bind_field", E <$> pMutBindField)
    , ("bind_positional_fields", E <$> pBindPositionalFields)
    , ("comma_bind_list", E <$> pCommaBindList)
    , ("or_bind_list", E <$> pOrBindList)
    , ("match_condition", E <$> pMatchCondition)
    , ("pack_expression", E <$> pPackExpression)
    , ("field_initialize_list", E <$> pFieldInitializeList)
    , ("exp_field", E <$> pExpField)
    , ("spec_block", E <$> pSpecBlock)
    , ("spec_block_internal0", E <$> pSpecBlockInternal0)
    , ("_spec_block_target", E <$> pHiddenSpecBlockTarget)
    , ("spec_block_target_schema", E <$> pSpecBlockTargetSchema)
    , ("_struct_identifier", E <$> pHiddenStructIdentifier)
    , ("_spec_function", E <$> pHiddenSpecFunction)
    , ("native_spec_function", E <$> pNativeSpecFunction)
    , ("_spec_function_signature", E <$> pHiddenSpecFunctionSignature)
    , ("uninterpreted_spec_function", E <$> pUninterpretedSpecFunction)
    , ("usual_spec_function", E <$> pUsualSpecFunction)
    , ("spec_body", E <$> pSpecBody)
    , ("_spec_block_memeber", E <$> pHiddenSpecBlockMemeber)
    , ("spec_apply", E <$> pSpecApply)
    , ("spec_apply_pattern", E <$> pSpecApplyPattern)
    , ("spec_apply_name_pattern", E <$> pSpecApplyNamePattern)
    , ("spec_apply_pattern_internal0", E <$> pSpecApplyPatternInternal0)
    , ("spec_condition", E <$> pSpecCondition)
    , ("_spec_abort_if", E <$> pHiddenSpecAbortIf)
    , ("condition_properties", E <$> pConditionProperties)
    , ("spec_property", E <$> pSpecProperty)
    , ("_spec_abort_with_or_modifies", E <$> pHiddenSpecAbortWithOrModifies)
    , ("_spec_abort_with_or_modifies_internal0", E <$> pHiddenSpecAbortWithOrModifiesInternal0)
    , ("_spec_condition", E <$> pHiddenSpecCondition)
    , ("_spec_condition_internal0", E <$> pHiddenSpecConditionInternal0)
    , ("_spec_condition_kind", E <$> pHiddenSpecConditionKind)
    , ("spec_include", E <$> pSpecInclude)
    , ("spec_invariant", E <$> pSpecInvariant)
    , ("spec_invariant_internal0", E <$> pSpecInvariantInternal0)
    , ("spec_let", E <$> pSpecLet)
    , ("spec_pragma", E <$> pSpecPragma)
    , ("spec_variable", E <$> pSpecVariable)
    , ("spec_variable_internal0", E <$> pSpecVariableInternal0)
    , ("use_declaration", E <$> pUseDeclaration)
    , ("use_declaration_internal0", E <$> pUseDeclarationInternal0)
    , ("use_fun", E <$> pUseFun)
    , ("use_module", E <$> pUseModule)
    , ("use_module_member", E <$> pUseModuleMember)
    , ("use_member", E <$> pUseMember)
    , ("use_module_members", E <$> pUseModuleMembers)
    , ("unit_expression", E <$> pUnitExpression)
    , ("vector_expression", E <$> pVectorExpression)
    , ("vector_expression_internal0", E <$> pVectorExpressionInternal0)
    , ("borrow_expression", E <$> pBorrowExpression)
    , ("dereference_expression", E <$> pDereferenceExpression)
    , ("move_or_copy_expression", E <$> pMoveOrCopyExpression)
    , ("move_or_copy_expression_internal0", E <$> pMoveOrCopyExpressionInternal0)
    , ("unary_expression", E <$> pUnaryExpression)
    , ("unary_op", E <$> pUnaryOp)
    , ("abort_expression", E <$> pAbortExpression)
    , ("assign_expression", E <$> pAssignExpression)
    , ("binary_expression", E <$> pBinaryExpression)
    , ("cast_expression", E <$> pCastExpression)
    , ("identified_expression", E <$> pIdentifiedExpression)
    , ("block_identifier", E <$> pBlockIdentifier)
    , ("lambda_expression", E <$> pLambdaExpression)
    , ("lambda_bindings", E <$> pLambdaBindings)
    , ("lambda_binding", E <$> pLambdaBinding)
    , ("loop_expression", E <$> pLoopExpression)
    , ("quantifier_expression", E <$> pQuantifierExpression)
    , ("quantifier_bindings", E <$> pQuantifierBindings)
    , ("quantifier_binding", E <$> pQuantifierBinding)
    , ("quantifier_expression_internal0", E <$> pQuantifierExpressionInternal0)
    , ("return_expression", E <$> pReturnExpression)
    , ("while_expression", E <$> pWhileExpression)
    , ("block_item", E <$> pBlockItem)
    , ("block_item_internal0", E <$> pBlockItemInternal0)
    , ("let_statement", E <$> pLetStatement)
    , ("macro_function_definition", E <$> pMacroFunctionDefinition)
    , ("_macro_signature", E <$> pHiddenMacroSignature)
    , ("native_function_definition", E <$> pNativeFunctionDefinition)
    , ("_struct_item", E <$> pHiddenStructItem)
    , ("native_struct_definition", E <$> pNativeStructDefinition)
    , ("_struct_signature", E <$> pHiddenStructSignature)
    , ("struct_definition", E <$> pStructDefinition)
    , ("constant", E <$> pConstant)
    , ("friend_declaration", E <$> pFriendDeclaration)
    , ("friend_access", E <$> pFriendAccess)
    , ("module_extension_definition", E <$> pModuleExtensionDefinition)
    , ("!", E <$> pExclamationMarkTok)
    , ("!=", E <$> pExclamationMarkEqualsSignTok)
    , ("#[", E <$> pNumberSignLeftSquareBracketTok)
    , ("$", E <$> pDollarSignTok)
    , ("%", E <$> pPercentSignTok)
    , ("&", E <$> pAmpersandTok)
    , ("&&", E <$> pAmpersandAmpersandTok)
    , ("'", E <$> pApostropheTok)
    , ("(", E <$> pLeftParenthesisTok)
    , (")", E <$> pRightParenthesisTok)
    , ("*", E <$> pAsteriskTok)
    , ("+", E <$> pPlusSignTok)
    , (",", E <$> pCommaTok)
    , ("-", E <$> pHyphenMinusTok)
    , ("->", E <$> pHyphenMinusGreaterThanSignTok)
    , (".", E <$> pFullStopTok)
    , ("..", E <$> pFullStopFullStopTok)
    , ("/", E <$> pSolidusTok)
    , ("/*", E <$> pSolidusAsteriskTok)
    , ("//", E <$> pSolidusSolidusTok)
    , (":", E <$> pColonTok)
    , ("::", E <$> pColonColonTok)
    , (";", E <$> pSemicolonTok)
    , ("<", E <$> pLessThanSignTok)
    , ("<<", E <$> pLessThanSignLessThanSignTok)
    , ("<=", E <$> pLessThanSignEqualsSignTok)
    , ("=", E <$> pEqualsSignTok)
    , ("==", E <$> pEqualsSignEqualsSignTok)
    , ("==>", E <$> pEqualsSignEqualsSignGreaterThanSignTok)
    , ("=>", E <$> pEqualsSignGreaterThanSignTok)
    , (">", E <$> pGreaterThanSignTok)
    , (">=", E <$> pGreaterThanSignEqualsSignTok)
    , (">>", E <$> pGreaterThanSignGreaterThanSignTok)
    , ("@", E <$> pCommercialAtTok)
    , ("[", E <$> pLeftSquareBracketTok)
    , ("]", E <$> pRightSquareBracketTok)
    , ("^", E <$> pCircumflexAccentTok)
    , ("abort", E <$> pAbortTok)
    , ("aborts_if", E <$> pAbortsIfTok)
    , ("aborts_with", E <$> pAbortsWithTok)
    , ("address", E <$> pAddressTok)
    , ("apply", E <$> pApplyTok)
    , ("as", E <$> pAsTok)
    , ("assert", E <$> pAssertTok)
    , ("assume", E <$> pAssumeTok)
    , ("bool", E <$> pBoolTok)
    , ("break", E <$> pBreakTok)
    , ("const", E <$> pConstTok)
    , ("continue", E <$> pContinueTok)
    , ("copy", E <$> pCopyTok)
    , ("decreases", E <$> pDecreasesTok)
    , ("drop", E <$> pDropTok)
    , ("else", E <$> pElseTok)
    , ("ensures", E <$> pEnsuresTok)
    , ("entry", E <$> pEntryTok)
    , ("enum", E <$> pEnumTok)
    , ("except", E <$> pExceptTok)
    , ("exists", E <$> pExistsTok)
    , ("extend", E <$> pExtendTok)
    , ("false", E <$> pFalseTok)
    , ("forall", E <$> pForallTok)
    , ("friend", E <$> pFriendTok)
    , ("fun", E <$> pFunTok)
    , ("global", E <$> pGlobalTok)
    , ("has", E <$> pHasTok)
    , ("if", E <$> pIfTok)
    , ("in", E <$> pInTok)
    , ("include", E <$> pIncludeTok)
    , ("internal", E <$> pInternalTok)
    , ("invariant", E <$> pInvariantTok)
    , ("key", E <$> pKeyTok)
    , ("let", E <$> pLetTok)
    , ("local", E <$> pLocalTok)
    , ("loop", E <$> pLoopTok)
    , ("macro", E <$> pMacroTok)
    , ("match", E <$> pMatchTok)
    , ("modifies", E <$> pModifiesTok)
    , ("module", E <$> pModuleTok)
    , ("move", E <$> pMoveTok)
    , ("mut", E <$> pMutTok)
    , ("native", E <$> pNativeTok)
    , ("pack", E <$> pPackTok)
    , ("package", E <$> pPackageTok)
    , ("phantom", E <$> pPhantomTok)
    , ("post", E <$> pPostTok)
    , ("pragma", E <$> pPragmaTok)
    , ("public", E <$> pPublicTok)
    , ("requires", E <$> pRequiresTok)
    , ("return", E <$> pReturnTok)
    , ("schema", E <$> pSchemaTok)
    , ("signer", E <$> pSignerTok)
    , ("spec", E <$> pSpecTok)
    , ("store", E <$> pStoreTok)
    , ("struct", E <$> pStructTok)
    , ("succeeds_if", E <$> pSucceedsIfTok)
    , ("to", E <$> pToTok)
    , ("true", E <$> pTrueTok)
    , ("u128", E <$> pU128Tok)
    , ("u16", E <$> pU16Tok)
    , ("u256", E <$> pU256Tok)
    , ("u32", E <$> pU32Tok)
    , ("u64", E <$> pU64Tok)
    , ("u8", E <$> pU8Tok)
    , ("unpack", E <$> pUnpackTok)
    , ("update", E <$> pUpdateTok)
    , ("use", E <$> pUseTok)
    , ("vector<", E <$> pVectorLessThanSignTok)
    , ("vector[", E <$> pVectorLeftSquareBracketTok)
    , ("where", E <$> pWhereTok)
    , ("while", E <$> pWhileTok)
    , ("with", E <$> pWithTok)
    , ("{", E <$> pLeftCurlyBracketTok)
    , ("|", E <$> pVerticalLineTok)
    , ("||", E <$> pVerticalLineVerticalLineTok)
    , ("}", E <$> pRightCurlyBracketTok)
    ]

mkParseTable :: TS.Language -> IO ParseTable
mkParseTable lang = do
  count <- fromIntegral <$> TS.languageSymbolCount lang
  SymbolTable <$> foldrM
    (\id acc -> do
      symName <- TS.languageSymbolName lang id
      let mSymSing = Map.lookup (Char8.unpack symName) symbolMap
      pure (maybe acc (flip (IM.insert (fromIntegral id)) acc) mSymSing)
    )
    (IM.empty :: IntMap SomeTermParser)
    [0..count - 1]
