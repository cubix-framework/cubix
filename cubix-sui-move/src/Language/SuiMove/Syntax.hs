-- Language definition for SuiMove, generated by gen-syntax. Do not edit!
{-# LANGUAGE CPP #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE QuantifiedConstraints #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# OPTIONS_GHC -fno-warn-redundant-constraints #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Language.SuiMove.Syntax (module Language.SuiMove.Syntax, getTestCorpusDir) where

-- import qualified AST.Parse
-- import qualified AST.Token
-- import qualified AST.Traversable1.Class
import qualified Data.Foldable
import qualified Data.Functor.Classes
import qualified Data.List as Data.OldList
import qualified Data.Maybe as GHC.Maybe
import qualified Data.Text.Internal
import qualified Data.Traversable
import qualified GHC.Base
import qualified GHC.Generics
import qualified GHC.Records
import qualified GHC.Show
import qualified TreeSitter.Node
import TreeSitter.SuiMove (getTestCorpusDir)
import qualified Prelude as GHC.Classes
import qualified Prelude as GHC.Types

debugSymbolNames :: [GHC.Base.String]
debugSymbolNames = debugSymbolNames_0

debugSymbolNames_0 :: [GHC.Base.String]
debugSymbolNames_0 =
  [ "_end"
  , "identifier"
  , "_public"
  , "_use"
  , "_;"
  , "_fun"
  , "_as"
  , "_."
  , "_::"
  , "_{"
  , "_,"
  , "_}"
  , "_friend"
  , "_("
  , "_package"
  , "_)"
  , "_entry"
  , "_native"
  , "_copy"
  , "_drop"
  , "_store"
  , "_key"
  , "_module"
  , "_#["
  , "_]"
  , "_="
  , "_const"
  , "_:"
  , "_enum"
  , "_has"
  , "_struct"
  , "_macro"
  , "_spec"
  , "_schema"
  , "_let"
  , "_post"
  , "_assert"
  , "_assume"
  , "_decreases"
  , "_ensures"
  , "_succeeds_if"
  , "condition_kind"
  , "condition_kind"
  , "_with"
  , "condition_kind"
  , "condition_kind"
  , "condition_kind"
  , "invariant_modifier"
  , "invariant_modifier"
  , "invariant_modifier"
  , "_["
  , "_include"
  , "_apply"
  , "_to"
  , "_except"
  , "_internal"
  , "spec_apply_name_pattern"
  , "_pragma"
  , "_global"
  , "_local"
  , "_u8"
  , "_u16"
  , "_u32"
  , "_u64"
  , "_u128"
  , "_u256"
  , "_bool"
  , "_address"
  , "_signer"
  , "_bytearray"
  , "_$"
  , "_@"
  , "_!"
  , "_<"
  , "_>"
  , "_->"
  , "_|"
  , "_mut"
  , "_phantom"
  , "_+"
  , "_vector["
  , "_vector<"
  , "_where"
  , "_in"
  , "_if"
  , "_else"
  , "_while"
  , "_loop"
  , "_return"
  , "_abort"
  , "_match"
  , "_=>"
  , "binary_operator"
  , "binary_operator"
  , "binary_operator"
  , "binary_operator"
  , "binary_operator"
  , "binary_operator"
  , "binary_operator"
  , "_.."
  , "binary_operator"
  , "_&"
  , "binary_operator"
  , "binary_operator"
  , "binary_operator"
  , "_*"
  , "binary_operator"
  , "binary_operator"
  , "_move"
  , "_break"
  , "_continue"
  , "_'"
  , "address_literal"
  , "_true"
  , "_false"
  , "_num_literal_token1"
  , "_num_literal_token2"
  , "hex_string_literal"
  , "byte_string_literal"
  , "__forall"
  , "__exists"
  , "line_comment"
  , "newline"
  , "__whitespace"
  , "block_comment"
  , "source_file"
  , "use_declaration"
  , "use_fun"
  , "use_module"
  , "use_module_member"
  , "use_module_members"
  , "use_member"
  , "friend_declaration"
  , "modifier"
  , "ability"
  , "module_definition"
  , "module_body"
  , "annotation"
  , "annotation_expr"
  , "annotation_list"
  , "annotation_item"
  , "constant"
  , "datatype_fields"
  , "positional_fields"
  , "named_fields"
  , "__enum_item"
  , "enum_definition"
  , "__enum_signature"
  , "enum_variants"
  , "variant"
  , "__struct_item"
  , "native_struct_definition"
  , "struct_definition"
  , "field_annotation"
  , "ability_decls"
  , "postfix_ability_decls"
  , "__struct_signature"
  , "__function_item"
  , "native_function_definition"
  , "macro_function_definition"
  , "__macro_signature"
  , "function_definition"
  , "__function_signature"
  , "function_parameters"
  , "spec_block"
  , "__spec_block_target"
  , "spec_block_target_schema"
  , "spec_body"
  , "__spec_block_memeber"
  , "spec_let"
  , "spec_condition"
  , "condition_kind"
  , "__spec_condition"
  , "__spec_abort_if"
  , "__spec_abort_with_or_modifies"
  , "spec_invariant"
  , "condition_properties"
  , "spec_include"
  , "spec_apply"
  , "spec_apply_pattern"
  , "spec_pragma"
  , "spec_property"
  , "spec_variable"
  , "__spec_function"
  , "uninterpreted_spec_function"
  , "native_spec_function"
  , "usual_spec_function"
  , "__spec_function_signature"
  , "__type"
  , "apply_type"
  , "ref_type"
  , "tuple_type"
  , "primitive_type"
  , "ret_type"
  , "module_access"
  , "friend_access"
  , "macro_module_access"
  , "module_identity"
  , "type_arguments"
  , "function_type"
  , "function_type_parameters"
  , "mut_function_parameter"
  , "function_parameter"
  , "type_parameters"
  , "type_parameter"
  , "block"
  , "block_item"
  , "let_statement"
  , "__expression"
  , "identified_expression"
  , "vector_expression"
  , "quantifier_expression"
  , "quantifier_bindings"
  , "quantifier_binding"
  , "lambda_expression"
  , "lambda_binding"
  , "lambda_bindings"
  , "if_expression"
  , "while_expression"
  , "loop_expression"
  , "return_expression"
  , "abort_expression"
  , "match_expression"
  , "__match_body"
  , "match_condition"
  , "match_arm"
  , "call_expression"
  , "macro_call_expression"
  , "pack_expression"
  , "name_expression"
  , "assign_expression"
  , "binary_expression"
  , "__unary_expression"
  , "unary_expression"
  , "unary_op"
  , "dereference_expression"
  , "borrow_expression"
  , "move_or_copy_expression"
  , "__reference"
  , "__expression_term"
  , "break_expression"
  , "continue_expression"
  , "field_initialize_list"
  , "arg_list"
  , "expression_list"
  , "unit_expression"
  , "cast_expression"
  , "annotation_expression"
  , "dot_expression"
  , "index_expression"
  , "exp_field"
  , "bind_list"
  , "at_bind"
  , "comma_bind_list"
  , "or_bind_list"
  , "mut_bind_var"
  , "__bind"
  , "bind_unpack"
  , "bind_fields"
  , "__spread_operator"
  , "bind_positional_fields"
  , "bind_named_fields"
  , "mut_bind_field"
  , "bind_field"
  , "__literal_value"
  , "imm_ref"
  , "mut_ref"
  , "block_identifier"
  , "label"
  , "bool_literal"
  , "num_literal"
  , "__module_identifier"
  , "__struct_identifier"
  , "__enum_identifier"
  , "__variant_identifier"
  , "__function_identifier"
  , "__variable_identifier"
  , "__field_identifier"
  , "__type_parameter_identifier"
  , "identifier"
  , "_source_file_repeat1"
  , "_use_module_members_repeat1"
  , "_module_body_repeat1"
  , "_annotation_repeat1"
  , "_annotation_list_repeat1"
  , "_positional_fields_repeat1"
  , "_named_fields_repeat1"
  , "_enum_variants_repeat1"
  , "_ability_decls_repeat1"
  , "_function_parameters_repeat1"
  , "_spec_body_repeat1"
  , "_spec_body_repeat2"
  , "__spec_abort_with_or_modifies_repeat1"
  , "_condition_properties_repeat1"
  , "_spec_apply_repeat1"
  , "_type_arguments_repeat1"
  , "_type_parameters_repeat1"
  , "_type_parameter_repeat1"
  , "_block_repeat1"
  , "_vector_expression_repeat1"
  , "_quantifier_bindings_repeat1"
  , "_lambda_bindings_repeat1"
  , "__match_body_repeat1"
  , "_field_initialize_list_repeat1"
  , "_expression_list_repeat1"
  , "_index_expression_repeat1"
  , "_comma_bind_list_repeat1"
  , "_or_bind_list_repeat1"
  , "_bind_positional_fields_repeat1"
  , "bind_var"
  , "constant_identifier"
  , "enum_identifier"
  , "field_identifier"
  , "function_identifier"
  , "module_identifier"
  , "spec_block_target_module"
  , "struct_identifier"
  , "type_parameter_identifier"
  , "variable_identifier"
  , "variant_identifier"
  ]

newtype SpecBlockTarget a = SpecBlockTarget {getSpecBlockTarget :: ((Identifier GHC.Generics.:+: (SpecBlockTargetModule GHC.Generics.:+: SpecBlockTargetSchema)) a)}

data Ability a = Ability {ann :: a, text :: Data.Text.Internal.Text}

data AbilityDecls a = AbilityDecls {ann :: a, extraChildren :: [f (Ability a)]}

data AbortExpression a = AbortExpression
  { ann :: a
  , abort :: (GHC.Maybe.Maybe (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  }

data Annotation a = Annotation
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f (AnnotationItem a)))
  }

data AnnotationExpr a = AnnotationExpr
  { ann :: a
  , value :: (GHC.Maybe.Maybe (f (((AddressLiteral GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: ByteStringLiteral)) GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: (ModuleAccess GHC.Generics.:+: NumLiteral))) a)))
  , localConst :: [f ((AnonymousColonColon GHC.Generics.:+: ModuleAccess) a)]
  , name :: (f (Identifier a))
  }

data AnnotationExpression a = AnnotationExpression
  { ann :: a
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , ty :: (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a))
  }

data AnnotationItem a = AnnotationItem
  { ann :: a
  , annotationList :: (GHC.Maybe.Maybe (f (AnnotationList a)))
  , annotationExpr :: (GHC.Maybe.Maybe (f (AnnotationExpr a)))
  }

data AnnotationList a = AnnotationList
  { ann :: a
  , localConst :: [f ((AnonymousColonColon GHC.Generics.:+: ModuleAccess) a)]
  , name :: (f (Identifier a))
  , extraChildren :: [f (((AddressLiteral GHC.Generics.:+: (AnnotationItem GHC.Generics.:+: BoolLiteral)) GHC.Generics.:+: ((ByteStringLiteral GHC.Generics.:+: HexStringLiteral) GHC.Generics.:+: (ModuleAccess GHC.Generics.:+: NumLiteral))) a)]
  }

data ApplyType a = ApplyType
  { ann :: a
  , typeArguments :: (GHC.Maybe.Maybe (f (TypeArguments a)))
  , extraChildren :: (f (ModuleAccess a))
  }

data ArgList a = ArgList
  { ann :: a
  , extraChildren :: [f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)]
  }

data AssignExpression a = AssignExpression
  { ann :: a
  , lhs :: (f (((((AddressLiteral GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: Block)) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: (BorrowExpression GHC.Generics.:+: BreakExpression))) GHC.Generics.:+: ((ByteStringLiteral GHC.Generics.:+: (CallExpression GHC.Generics.:+: ContinueExpression)) GHC.Generics.:+: (DereferenceExpression GHC.Generics.:+: (DotExpression GHC.Generics.:+: ExpressionList)))) GHC.Generics.:+: (((HexStringLiteral GHC.Generics.:+: (IfExpression GHC.Generics.:+: IndexExpression)) GHC.Generics.:+: (MacroCallExpression GHC.Generics.:+: (MatchExpression GHC.Generics.:+: MoveOrCopyExpression))) GHC.Generics.:+: ((NameExpression GHC.Generics.:+: (NumLiteral GHC.Generics.:+: PackExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: VectorExpression))))) a))
  , rhs :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data AtBind a = AtBind
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f ((BindList GHC.Generics.:+: VariableIdentifier) a)))
  }

data BinaryExpression a = BinaryExpression
  { ann :: a
  , lhs :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , rhs :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , operator :: (f (BinaryOperator a))
  }

data BindField a = BindField
  { ann :: a
  , bind :: (GHC.Maybe.Maybe (f (BindList a)))
  , field :: (GHC.Maybe.Maybe (f (BindList a)))
  }

data BindFields a = BindFields
  { ann :: a
  , extraChildren :: (f ((BindNamedFields GHC.Generics.:+: BindPositionalFields) a))
  }

data BindList a = BindList
  { ann :: a
  , extraChildren :: (f ((((AddressLiteral GHC.Generics.:+: AtBind) GHC.Generics.:+: (BindUnpack GHC.Generics.:+: (BindVar GHC.Generics.:+: BoolLiteral))) GHC.Generics.:+: ((ByteStringLiteral GHC.Generics.:+: (CommaBindList GHC.Generics.:+: HexStringLiteral)) GHC.Generics.:+: (MutBindVar GHC.Generics.:+: (NumLiteral GHC.Generics.:+: OrBindList)))) a))
  }

data BindNamedFields a = BindNamedFields
  { ann :: a
  , extraChildren :: [f ((BindField GHC.Generics.:+: MutBindField) a)]
  }

data BindPositionalFields a = BindPositionalFields
  { ann :: a
  , extraChildren :: [f ((BindField GHC.Generics.:+: MutBindField) a)]
  }

data BindUnpack a = BindUnpack
  { ann :: a
  , bindFields :: (GHC.Maybe.Maybe (f (BindFields a)))
  , extraChildren :: (f (NameExpression a))
  }

data BindVar a = BindVar {ann :: a, extraChildren :: (f (VariableIdentifier a))}

data Block a = Block
  { ann :: a
  , extraChildren :: [f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BlockItem GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression)))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: (ReturnExpression GHC.Generics.:+: SpecBlock))) GHC.Generics.:+: ((UnaryExpression GHC.Generics.:+: UnitExpression) GHC.Generics.:+: (UseDeclaration GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)]
  }

data BlockIdentifier a = BlockIdentifier {ann :: a, extraChildren :: (f (Label a))}

data BlockItem a = BlockItem
  { ann :: a
  , extraChildren :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: (BorrowExpression GHC.Generics.:+: BreakExpression)))) GHC.Generics.:+: (((ByteStringLiteral GHC.Generics.:+: CallExpression) GHC.Generics.:+: (CastExpression GHC.Generics.:+: ContinueExpression)) GHC.Generics.:+: ((DereferenceExpression GHC.Generics.:+: DotExpression) GHC.Generics.:+: (ExpressionList GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: IdentifiedExpression))))) GHC.Generics.:+: ((((IfExpression GHC.Generics.:+: IndexExpression) GHC.Generics.:+: (LambdaExpression GHC.Generics.:+: LetStatement)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data BoolLiteral a = BoolLiteral {ann :: a, text :: Data.Text.Internal.Text}

data BorrowExpression a = BorrowExpression
  { ann :: a
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , extraChildren :: (f ((ImmRef GHC.Generics.:+: MutRef) a))
  }

data BreakExpression a = BreakExpression
  { ann :: a
  , break :: (GHC.Maybe.Maybe (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  , label :: (GHC.Maybe.Maybe (f (Label a)))
  }

data CallExpression a = CallExpression
  { ann :: a
  , args :: (f (ArgList a))
  , extraChildren :: (f (NameExpression a))
  }

data CastExpression a = CastExpression
  { ann :: a
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , ty :: (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a))
  }

data CommaBindList a = CommaBindList
  { ann :: a
  , extraChildren :: [f ((((AddressLiteral GHC.Generics.:+: AtBind) GHC.Generics.:+: (BindUnpack GHC.Generics.:+: BindVar)) GHC.Generics.:+: ((BoolLiteral GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: (MutBindVar GHC.Generics.:+: NumLiteral)))) a)]
  }

data ConditionKind a = ConditionKind {ann :: a, text :: Data.Text.Internal.Text}

data ConditionProperties a = ConditionProperties
  { ann :: a
  , extraChildren :: [f (SpecProperty a)]
  }

data Constant a = Constant
  { ann :: a
  , type' :: (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a))
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , name :: (f (ConstantIdentifier a))
  }

data ContinueExpression a = ContinueExpression
  { ann :: a
  , label :: (GHC.Maybe.Maybe (f (Label a)))
  }

data DatatypeFields a = DatatypeFields
  { ann :: a
  , extraChildren :: (f ((NamedFields GHC.Generics.:+: PositionalFields) a))
  }

data DereferenceExpression a = DereferenceExpression
  { ann :: a
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data DotExpression a = DotExpression
  { ann :: a
  , access :: (f (((((AddressLiteral GHC.Generics.:+: AnnotationExpression) GHC.Generics.:+: (Block GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BreakExpression))) GHC.Generics.:+: ((ByteStringLiteral GHC.Generics.:+: CallExpression) GHC.Generics.:+: (ContinueExpression GHC.Generics.:+: (DotExpression GHC.Generics.:+: ExpressionList)))) GHC.Generics.:+: (((HexStringLiteral GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: (MacroCallExpression GHC.Generics.:+: MatchExpression))) GHC.Generics.:+: ((NameExpression GHC.Generics.:+: (NumLiteral GHC.Generics.:+: PackExpression)) GHC.Generics.:+: (SpecBlock GHC.Generics.:+: (UnitExpression GHC.Generics.:+: VectorExpression))))) a))
  , expr :: (f (((((AddressLiteral GHC.Generics.:+: AnnotationExpression) GHC.Generics.:+: (Block GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BreakExpression))) GHC.Generics.:+: ((ByteStringLiteral GHC.Generics.:+: CallExpression) GHC.Generics.:+: (ContinueExpression GHC.Generics.:+: (DotExpression GHC.Generics.:+: ExpressionList)))) GHC.Generics.:+: (((HexStringLiteral GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: (MacroCallExpression GHC.Generics.:+: MatchExpression))) GHC.Generics.:+: ((NameExpression GHC.Generics.:+: (NumLiteral GHC.Generics.:+: PackExpression)) GHC.Generics.:+: (SpecBlock GHC.Generics.:+: (UnitExpression GHC.Generics.:+: VectorExpression))))) a))
  }

data EnumDefinition a = EnumDefinition
  { ann :: a
  , enumVariants :: (f (EnumVariants a))
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , postfixAbilityDeclarations :: (GHC.Maybe.Maybe (f (PostfixAbilityDecls a)))
  , abilityDeclarations :: (GHC.Maybe.Maybe (f (AbilityDecls a)))
  , name :: (f (EnumIdentifier a))
  }

data EnumVariants a = EnumVariants {ann :: a, extraChildren :: [f (Variant a)]}

data ExpField a = ExpField
  { ann :: a
  , expr :: (GHC.Maybe.Maybe (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  , field :: (f (FieldIdentifier a))
  }

data ExpressionList a = ExpressionList
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  }

data FieldAnnotation a = FieldAnnotation
  { ann :: a
  , type' :: (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a))
  , field :: (f (FieldIdentifier a))
  }

data FieldInitializeList a = FieldInitializeList {ann :: a, extraChildren :: [f (ExpField a)]}

data FriendAccess a = FriendAccess
  { ann :: a
  , fullyQualifiedModule :: (GHC.Maybe.Maybe (f (ModuleIdentity a)))
  , localModule :: (GHC.Maybe.Maybe (f (Identifier a)))
  }

data FriendDeclaration a = FriendDeclaration {ann :: a, module' :: (f (FriendAccess a))}

data FunctionDefinition a = FunctionDefinition
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , returnType :: (GHC.Maybe.Maybe (f (RetType a)))
  , parameters :: (f (FunctionParameters a))
  , name :: (f (FunctionIdentifier a))
  , body :: (f (Block a))
  , extraChildren :: [f (Modifier a)]
  }

data FunctionParameter a = FunctionParameter
  { ann :: a
  , type' :: (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a))
  , name :: (f (VariableIdentifier a))
  }

data FunctionParameters a = FunctionParameters
  { ann :: a
  , extraChildren :: [f ((FunctionParameter GHC.Generics.:+: MutFunctionParameter) a)]
  }

data FunctionType a = FunctionType
  { ann :: a
  , returnType :: (GHC.Maybe.Maybe (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)))
  , paramTypes :: (f (FunctionTypeParameters a))
  }

data FunctionTypeParameters a = FunctionTypeParameters
  { ann :: a
  , extraChildren :: [f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)]
  }

data IdentifiedExpression a = IdentifiedExpression
  { ann :: a
  , expressionId :: (f (BlockIdentifier a))
  , extraChildren :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data Identifier a = Identifier {ann :: a, text :: Data.Text.Internal.Text}

data IfExpression a = IfExpression
  { ann :: a
  , eb :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , et :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , ef :: (GHC.Maybe.Maybe (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  }

data ImmRef a = ImmRef {ann :: a, text :: Data.Text.Internal.Text}

data IndexExpression a = IndexExpression
  { ann :: a
  , idx :: [f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)]
  , expr :: (f (((((AddressLiteral GHC.Generics.:+: AnnotationExpression) GHC.Generics.:+: (Block GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BreakExpression))) GHC.Generics.:+: ((ByteStringLiteral GHC.Generics.:+: CallExpression) GHC.Generics.:+: (ContinueExpression GHC.Generics.:+: (DotExpression GHC.Generics.:+: ExpressionList)))) GHC.Generics.:+: (((HexStringLiteral GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: (MacroCallExpression GHC.Generics.:+: MatchExpression))) GHC.Generics.:+: ((NameExpression GHC.Generics.:+: (NumLiteral GHC.Generics.:+: PackExpression)) GHC.Generics.:+: (SpecBlock GHC.Generics.:+: (UnitExpression GHC.Generics.:+: VectorExpression))))) a))
  }

data Label a = Label {ann :: a, extraChildren :: (f (Identifier a))}

data LambdaBinding a = LambdaBinding
  { ann :: a
  , bind :: (GHC.Maybe.Maybe (f ((((AddressLiteral GHC.Generics.:+: AtBind) GHC.Generics.:+: (BindUnpack GHC.Generics.:+: BindVar)) GHC.Generics.:+: ((BoolLiteral GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: (MutBindVar GHC.Generics.:+: NumLiteral)))) a)))
  , ty :: (GHC.Maybe.Maybe (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)))
  , extraChildren :: (GHC.Maybe.Maybe (f (CommaBindList a)))
  }

data LambdaBindings a = LambdaBindings {ann :: a, extraChildren :: [f (LambdaBinding a)]}

data LambdaExpression a = LambdaExpression
  { ann :: a
  , bindings :: (f (LambdaBindings a))
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , extraChildren :: (GHC.Maybe.Maybe (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)))
  }

data LetStatement a = LetStatement
  { ann :: a
  , type' :: (GHC.Maybe.Maybe (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)))
  , expr :: (GHC.Maybe.Maybe (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  , binds :: (f (BindList a))
  }

data LoopExpression a = LoopExpression
  { ann :: a
  , body :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data MacroCallExpression a = MacroCallExpression
  { ann :: a
  , args :: (f (ArgList a))
  , typeArguments :: (GHC.Maybe.Maybe (f (TypeArguments a)))
  , access :: (f (MacroModuleAccess a))
  }

data MacroFunctionDefinition a = MacroFunctionDefinition
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , returnType :: (GHC.Maybe.Maybe (f (RetType a)))
  , parameters :: (f (FunctionParameters a))
  , name :: (f (FunctionIdentifier a))
  , body :: (f (Block a))
  , extraChildren :: [f (Modifier a)]
  }

data MacroModuleAccess a = MacroModuleAccess {ann :: a, access :: (f (ModuleAccess a))}

data MatchArm a = MatchArm
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: BindList) GHC.Generics.:+: (Block GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression)))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchCondition GHC.Generics.:+: (MatchExpression GHC.Generics.:+: MoveOrCopyExpression)))) GHC.Generics.:+: (((NameExpression GHC.Generics.:+: NumLiteral) GHC.Generics.:+: (PackExpression GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression))) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  }

data MatchCondition a = MatchCondition
  { ann :: a
  , condition :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data MatchExpression a = MatchExpression
  { ann :: a
  , matchScrutiny :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , extraChildren :: [f (MatchArm a)]
  }

data Modifier a = Modifier {ann :: a, text :: Data.Text.Internal.Text}

data ModuleAccess a = ModuleAccess
  { ann :: a
  , typeArguments :: (GHC.Maybe.Maybe (f (TypeArguments a)))
  , variant :: (GHC.Maybe.Maybe (f (Identifier a)))
  , member :: (GHC.Maybe.Maybe (f (Identifier a)))
  , enumName :: (GHC.Maybe.Maybe (f (Identifier a)))
  , module' :: (GHC.Maybe.Maybe (f (ModuleIdentifier a)))
  , extraChildren :: (GHC.Maybe.Maybe (f (ModuleIdentity a)))
  }

data ModuleBody a = ModuleBody
  { ann :: a
  , extraChildren :: [f ((((Constant GHC.Generics.:+: EnumDefinition) GHC.Generics.:+: (FriendDeclaration GHC.Generics.:+: (FunctionDefinition GHC.Generics.:+: MacroFunctionDefinition))) GHC.Generics.:+: ((NativeFunctionDefinition GHC.Generics.:+: NativeStructDefinition) GHC.Generics.:+: (SpecBlock GHC.Generics.:+: (StructDefinition GHC.Generics.:+: UseDeclaration)))) a)]
  }

data ModuleDefinition a = ModuleDefinition
  { ann :: a
  , moduleBody :: (f (ModuleBody a))
  , moduleIdentity :: (f (ModuleIdentity a))
  }

data ModuleIdentity a = ModuleIdentity
  { ann :: a
  , address :: (f ((ModuleIdentifier GHC.Generics.:+: NumLiteral) a))
  , module' :: (f (ModuleIdentifier a))
  }

data MoveOrCopyExpression a = MoveOrCopyExpression
  { ann :: a
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data MutBindField a = MutBindField {ann :: a, extraChildren :: (f (BindField a))}

data MutBindVar a = MutBindVar {ann :: a, extraChildren :: (f (BindVar a))}

data MutFunctionParameter a = MutFunctionParameter
  { ann :: a
  , extraChildren :: (f (FunctionParameter a))
  }

data MutRef a = MutRef {ann :: a, text :: Data.Text.Internal.Text}

data NameExpression a = NameExpression {ann :: a, access :: (f (ModuleAccess a))}

data NamedFields a = NamedFields {ann :: a, extraChildren :: [f (FieldAnnotation a)]}

data NativeFunctionDefinition a = NativeFunctionDefinition
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , returnType :: (GHC.Maybe.Maybe (f (RetType a)))
  , parameters :: (f (FunctionParameters a))
  , name :: (f (FunctionIdentifier a))
  , extraChildren :: [f (Modifier a)]
  }

data NativeSpecFunction a = NativeSpecFunction
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , returnType :: (f (RetType a))
  , parameters :: (f (FunctionParameters a))
  , name :: (f (FunctionIdentifier a))
  }

data NativeStructDefinition a = NativeStructDefinition
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , abilityDeclarations :: (GHC.Maybe.Maybe (f (AbilityDecls a)))
  , name :: (f (StructIdentifier a))
  }

data NumLiteral a = NumLiteral {ann :: a, text :: Data.Text.Internal.Text}

data OrBindList a = OrBindList
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f ((((AddressLiteral GHC.Generics.:+: AtBind) GHC.Generics.:+: (BindUnpack GHC.Generics.:+: BindVar)) GHC.Generics.:+: ((BoolLiteral GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: (MutBindVar GHC.Generics.:+: NumLiteral)))) a)))
  }

data PackExpression a = PackExpression
  { ann :: a
  , body :: (f (FieldInitializeList a))
  , extraChildren :: (f (NameExpression a))
  }

data PositionalFields a = PositionalFields
  { ann :: a
  , extraChildren :: [f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)]
  }

data PostfixAbilityDecls a = PostfixAbilityDecls {ann :: a, extraChildren :: [f (Ability a)]}

data PrimitiveType a = PrimitiveType {ann :: a, text :: Data.Text.Internal.Text}

data QuantifierBinding a = QuantifierBinding
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: (ApplyType GHC.Generics.:+: AssignExpression))) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: (BorrowExpression GHC.Generics.:+: BreakExpression)))) GHC.Generics.:+: (((ByteStringLiteral GHC.Generics.:+: CallExpression) GHC.Generics.:+: (CastExpression GHC.Generics.:+: (ContinueExpression GHC.Generics.:+: DereferenceExpression))) GHC.Generics.:+: ((DotExpression GHC.Generics.:+: ExpressionList) GHC.Generics.:+: (FunctionType GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: IdentifiedExpression))))) GHC.Generics.:+: ((((Identifier GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: (LambdaExpression GHC.Generics.:+: LoopExpression))) GHC.Generics.:+: ((MacroCallExpression GHC.Generics.:+: MatchExpression) GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: (NameExpression GHC.Generics.:+: NumLiteral)))) GHC.Generics.:+: (((PackExpression GHC.Generics.:+: PrimitiveType) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: (RefType GHC.Generics.:+: ReturnExpression))) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: (TupleType GHC.Generics.:+: UnaryExpression)) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  }

data QuantifierBindings a = QuantifierBindings
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f (QuantifierBinding a)))
  }

data QuantifierExpression a = QuantifierExpression
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: (BorrowExpression GHC.Generics.:+: BreakExpression)))) GHC.Generics.:+: (((ByteStringLiteral GHC.Generics.:+: CallExpression) GHC.Generics.:+: (CastExpression GHC.Generics.:+: ContinueExpression)) GHC.Generics.:+: ((DereferenceExpression GHC.Generics.:+: DotExpression) GHC.Generics.:+: (ExpressionList GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: IdentifiedExpression))))) GHC.Generics.:+: ((((IfExpression GHC.Generics.:+: IndexExpression) GHC.Generics.:+: (LambdaExpression GHC.Generics.:+: LoopExpression)) GHC.Generics.:+: ((MacroCallExpression GHC.Generics.:+: MatchExpression) GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: (NameExpression GHC.Generics.:+: NumLiteral)))) GHC.Generics.:+: (((PackExpression GHC.Generics.:+: QuantifierBindings) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  }

data RefType a = RefType
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f (((ApplyType GHC.Generics.:+: (FunctionType GHC.Generics.:+: ImmRef)) GHC.Generics.:+: ((MutRef GHC.Generics.:+: PrimitiveType) GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)))
  }

data RetType a = RetType
  { ann :: a
  , extraChildren :: (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a))
  }

data ReturnExpression a = ReturnExpression
  { ann :: a
  , return :: (GHC.Maybe.Maybe (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  , label :: (GHC.Maybe.Maybe (f (Label a)))
  }

data SourceFile a = SourceFile {ann :: a, extraChildren :: [f (ModuleDefinition a)]}

data SpecApply a = SpecApply
  { ann :: a
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , extraChildren :: (GHC.Base.NonEmpty (f (SpecApplyPattern a)))
  }

data SpecApplyPattern a = SpecApplyPattern
  { ann :: a
  , namePattern :: (f (SpecApplyNamePattern a))
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  }

data SpecBlock a = SpecBlock
  { ann :: a
  , target :: (GHC.Maybe.Maybe (f (SpecBlockTarget a)))
  , body :: (GHC.Maybe.Maybe (f (SpecBody a)))
  , extraChildren :: (GHC.Maybe.Maybe (f ((NativeSpecFunction GHC.Generics.:+: (UninterpretedSpecFunction GHC.Generics.:+: UsualSpecFunction)) a)))
  }

data SpecBlockTargetSchema a = SpecBlockTargetSchema
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , name :: (f (StructIdentifier a))
  }

data SpecBody a = SpecBody
  { ann :: a
  , extraChildren :: [f ((((NativeSpecFunction GHC.Generics.:+: SpecApply) GHC.Generics.:+: (SpecCondition GHC.Generics.:+: (SpecInclude GHC.Generics.:+: SpecInvariant))) GHC.Generics.:+: ((SpecLet GHC.Generics.:+: (SpecPragma GHC.Generics.:+: SpecVariable)) GHC.Generics.:+: (UninterpretedSpecFunction GHC.Generics.:+: (UseDeclaration GHC.Generics.:+: UsualSpecFunction)))) a)]
  }

data SpecCondition a = SpecCondition
  { ann :: a
  , kind :: (f (ConditionKind a))
  , conditionProperties :: (GHC.Maybe.Maybe (f (ConditionProperties a)))
  , expr :: (GHC.Maybe.Maybe (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)))
  , additionalExp :: [f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)]
  }

data SpecInclude a = SpecInclude
  { ann :: a
  , extraChildren :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data SpecInvariant a = SpecInvariant
  { ann :: a
  , kind :: (f (ConditionKind a))
  , conditionProperties :: (GHC.Maybe.Maybe (f (ConditionProperties a)))
  , modifier :: (GHC.Maybe.Maybe (f (InvariantModifier a)))
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data SpecLet a = SpecLet
  { ann :: a
  , def :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , name :: (f (Identifier a))
  }

data SpecPragma a = SpecPragma {ann :: a, extraChildren :: [f (SpecProperty a)]}

data SpecProperty a = SpecProperty
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f (((AddressLiteral GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: ByteStringLiteral)) GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: (Identifier GHC.Generics.:+: NumLiteral))) a)))
  }

data SpecVariable a = SpecVariable
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , type' :: (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a))
  , name :: (f (Identifier a))
  }

data StructDefinition a = StructDefinition
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , postfixAbilityDeclarations :: (GHC.Maybe.Maybe (f (PostfixAbilityDecls a)))
  , abilityDeclarations :: (GHC.Maybe.Maybe (f (AbilityDecls a)))
  , name :: (f (StructIdentifier a))
  , structFields :: (f (DatatypeFields a))
  }

data TupleType a = TupleType
  { ann :: a
  , extraChildren :: [f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)]
  }

data TypeArguments a = TypeArguments
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f (((ApplyType GHC.Generics.:+: FunctionType) GHC.Generics.:+: (PrimitiveType GHC.Generics.:+: (RefType GHC.Generics.:+: TupleType))) a)))
  }

data TypeParameter a = TypeParameter
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f ((Ability GHC.Generics.:+: TypeParameterIdentifier) a)))
  }

data TypeParameters a = TypeParameters
  { ann :: a
  , extraChildren :: (GHC.Base.NonEmpty (f (TypeParameter a)))
  }

data UnaryExpression a = UnaryExpression
  { ann :: a
  , op :: (f (UnaryOp a))
  , expr :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

data UnaryOp a = UnaryOp {ann :: a, text :: Data.Text.Internal.Text}

data UninterpretedSpecFunction a = UninterpretedSpecFunction
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , returnType :: (f (RetType a))
  , parameters :: (f (FunctionParameters a))
  , name :: (f (FunctionIdentifier a))
  }

data UnitExpression a = UnitExpression {ann :: a, text :: Data.Text.Internal.Text}

data UseDeclaration a = UseDeclaration
  { ann :: a
  , extraChildren :: (f (((UseFun GHC.Generics.:+: UseModule) GHC.Generics.:+: (UseModuleMember GHC.Generics.:+: UseModuleMembers)) a))
  }

data UseFun a = UseFun
  { ann :: a
  , alias :: (GHC.Base.NonEmpty (f ((AnonymousDot GHC.Generics.:+: (FunctionIdentifier GHC.Generics.:+: ModuleAccess)) a)))
  , extraChildren :: (f (ModuleAccess a))
  }

data UseMember a = UseMember
  { ann :: a
  , alias :: (GHC.Maybe.Maybe (f (Identifier a)))
  , member :: (GHC.Maybe.Maybe (f (Identifier a)))
  , useMember :: [f (UseMember a)]
  , module' :: (GHC.Maybe.Maybe (f (Identifier a)))
  }

data UseModule a = UseModule
  { ann :: a
  , alias :: (GHC.Maybe.Maybe (f (ModuleIdentifier a)))
  , extraChildren :: (f (ModuleIdentity a))
  }

data UseModuleMember a = UseModuleMember
  { ann :: a
  , useMember :: (f (UseMember a))
  , extraChildren :: (f (ModuleIdentity a))
  }

data UseModuleMembers a = UseModuleMembers
  { ann :: a
  , address :: (GHC.Maybe.Maybe (f ((ModuleIdentifier GHC.Generics.:+: NumLiteral) a)))
  , useMember :: (GHC.Base.NonEmpty (f (UseMember a)))
  , extraChildren :: (GHC.Maybe.Maybe (f (ModuleIdentity a)))
  }

data UsualSpecFunction a = UsualSpecFunction
  { ann :: a
  , typeParameters :: (GHC.Maybe.Maybe (f (TypeParameters a)))
  , returnType :: (f (RetType a))
  , parameters :: (f (FunctionParameters a))
  , name :: (f (FunctionIdentifier a))
  , body :: (f (Block a))
  }

data Variant a = Variant
  { ann :: a
  , variantName :: (f (VariantIdentifier a))
  , fields :: (GHC.Maybe.Maybe (f (DatatypeFields a)))
  }

data VectorExpression a = VectorExpression
  { ann :: a
  , extraChildren :: [f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: (ApplyType GHC.Generics.:+: AssignExpression))) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: (BorrowExpression GHC.Generics.:+: BreakExpression)))) GHC.Generics.:+: (((ByteStringLiteral GHC.Generics.:+: CallExpression) GHC.Generics.:+: (CastExpression GHC.Generics.:+: (ContinueExpression GHC.Generics.:+: DereferenceExpression))) GHC.Generics.:+: ((DotExpression GHC.Generics.:+: ExpressionList) GHC.Generics.:+: (FunctionType GHC.Generics.:+: (HexStringLiteral GHC.Generics.:+: IdentifiedExpression))))) GHC.Generics.:+: ((((IfExpression GHC.Generics.:+: IndexExpression) GHC.Generics.:+: (LambdaExpression GHC.Generics.:+: (LoopExpression GHC.Generics.:+: MacroCallExpression))) GHC.Generics.:+: ((MatchExpression GHC.Generics.:+: MoveOrCopyExpression) GHC.Generics.:+: (NameExpression GHC.Generics.:+: (NumLiteral GHC.Generics.:+: PackExpression)))) GHC.Generics.:+: (((PrimitiveType GHC.Generics.:+: QuantifierExpression) GHC.Generics.:+: (RefType GHC.Generics.:+: (ReturnExpression GHC.Generics.:+: SpecBlock))) GHC.Generics.:+: ((TupleType GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a)]
  }

data WhileExpression a = WhileExpression
  { ann :: a
  , eb :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  , body :: (f ((((((AbortExpression GHC.Generics.:+: AddressLiteral) GHC.Generics.:+: (AnnotationExpression GHC.Generics.:+: AssignExpression)) GHC.Generics.:+: ((BinaryExpression GHC.Generics.:+: Block) GHC.Generics.:+: (BoolLiteral GHC.Generics.:+: BorrowExpression))) GHC.Generics.:+: (((BreakExpression GHC.Generics.:+: ByteStringLiteral) GHC.Generics.:+: (CallExpression GHC.Generics.:+: CastExpression)) GHC.Generics.:+: ((ContinueExpression GHC.Generics.:+: DereferenceExpression) GHC.Generics.:+: (DotExpression GHC.Generics.:+: (ExpressionList GHC.Generics.:+: HexStringLiteral))))) GHC.Generics.:+: ((((IdentifiedExpression GHC.Generics.:+: IfExpression) GHC.Generics.:+: (IndexExpression GHC.Generics.:+: LambdaExpression)) GHC.Generics.:+: ((LoopExpression GHC.Generics.:+: MacroCallExpression) GHC.Generics.:+: (MatchExpression GHC.Generics.:+: (MoveOrCopyExpression GHC.Generics.:+: NameExpression)))) GHC.Generics.:+: (((NumLiteral GHC.Generics.:+: PackExpression) GHC.Generics.:+: (QuantifierExpression GHC.Generics.:+: ReturnExpression)) GHC.Generics.:+: ((SpecBlock GHC.Generics.:+: UnaryExpression) GHC.Generics.:+: (UnitExpression GHC.Generics.:+: (VectorExpression GHC.Generics.:+: WhileExpression)))))) a))
  }

type AnonymousBang = AST.Token.Token "!" 72

type AnonymousHashLBracket = AST.Token.Token "#[" 23

type AnonymousDollar = AST.Token.Token "$" 70

type AnonymousAmpersand = AST.Token.Token "&" 101

type AnonymousSQuote = AST.Token.Token "'" 111

type AnonymousLParen = AST.Token.Token "(" 13

type AnonymousRParen = AST.Token.Token ")" 15

type AnonymousStar = AST.Token.Token "*" 105

type AnonymousPlus = AST.Token.Token "+" 79

type AnonymousComma = AST.Token.Token "," 10

type AnonymousMinusRAngle = AST.Token.Token "->" 75

type AnonymousDot = AST.Token.Token "." 7

type AnonymousDotDot = AST.Token.Token ".." 99

type AnonymousColon = AST.Token.Token ":" 27

type AnonymousColonColon = AST.Token.Token "::" 8

type AnonymousSemicolon = AST.Token.Token ";" 4

type AnonymousLAngle = AST.Token.Token "<" 73

type AnonymousEqual = AST.Token.Token "=" 25

type AnonymousEqualRAngle = AST.Token.Token "=>" 91

type AnonymousRAngle = AST.Token.Token ">" 74

type AnonymousAt = AST.Token.Token "@" 71

type AnonymousLBracket = AST.Token.Token "[" 50

type AnonymousRBracket = AST.Token.Token "]" 24

type AnonymousAbort = AST.Token.Token "abort" 89

type AnonymousAddress = AST.Token.Token "address" 67

data AddressLiteral a = AddressLiteral {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousApply = AST.Token.Token "apply" 52

type AnonymousAs = AST.Token.Token "as" 6

type AnonymousAssert = AST.Token.Token "assert" 36

type AnonymousAssume = AST.Token.Token "assume" 37

data BinaryOperator a = BinaryOperator {ann :: a, text :: Data.Text.Internal.Text}

data BlockComment a = BlockComment {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousBool = AST.Token.Token "bool" 66

type AnonymousBreak = AST.Token.Token "break" 109

data ByteStringLiteral a = ByteStringLiteral {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousBytearray = AST.Token.Token "bytearray" 69

type AnonymousConst = AST.Token.Token "const" 26

data ConstantIdentifier a = ConstantIdentifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousContinue = AST.Token.Token "continue" 110

type AnonymousCopy = AST.Token.Token "copy" 18

type AnonymousDecreases = AST.Token.Token "decreases" 38

type AnonymousDrop = AST.Token.Token "drop" 19

type AnonymousElse = AST.Token.Token "else" 85

type AnonymousEnsures = AST.Token.Token "ensures" 39

type AnonymousEntry = AST.Token.Token "entry" 16

type AnonymousEnum = AST.Token.Token "enum" 28

data EnumIdentifier a = EnumIdentifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousExcept = AST.Token.Token "except" 54

type AnonymousFalse = AST.Token.Token "false" 114

data FieldIdentifier a = FieldIdentifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousFriend = AST.Token.Token "friend" 12

type AnonymousFun = AST.Token.Token "fun" 5

data FunctionIdentifier a = FunctionIdentifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousGlobal = AST.Token.Token "global" 58

type AnonymousHas = AST.Token.Token "has" 29

data HexStringLiteral a = HexStringLiteral {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousIf = AST.Token.Token "if" 84

type AnonymousIn = AST.Token.Token "in" 83

type AnonymousInclude = AST.Token.Token "include" 51

type AnonymousInternal = AST.Token.Token "internal" 55

data InvariantModifier a = InvariantModifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousKey = AST.Token.Token "key" 21

type AnonymousLet = AST.Token.Token "let" 34

data LineComment a = LineComment {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousLocal = AST.Token.Token "local" 59

type AnonymousLoop = AST.Token.Token "loop" 87

type AnonymousMacro = AST.Token.Token "macro" 31

type AnonymousMatch = AST.Token.Token "match" 90

type AnonymousModule = AST.Token.Token "module" 22

data ModuleIdentifier a = ModuleIdentifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousMove = AST.Token.Token "move" 108

type AnonymousMut = AST.Token.Token "mut" 77

type AnonymousNative = AST.Token.Token "native" 17

data Newline a = Newline {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousPackage = AST.Token.Token "package" 14

type AnonymousPhantom = AST.Token.Token "phantom" 78

type AnonymousPost = AST.Token.Token "post" 35

type AnonymousPragma = AST.Token.Token "pragma" 57

type AnonymousPublic = AST.Token.Token "public" 2

type AnonymousReturn = AST.Token.Token "return" 88

type AnonymousSchema = AST.Token.Token "schema" 33

type AnonymousSigner = AST.Token.Token "signer" 68

type AnonymousSpec = AST.Token.Token "spec" 32

data SpecApplyNamePattern a = SpecApplyNamePattern {ann :: a, text :: Data.Text.Internal.Text}

data SpecBlockTargetModule a = SpecBlockTargetModule {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousStore = AST.Token.Token "store" 20

type AnonymousStruct = AST.Token.Token "struct" 30

data StructIdentifier a = StructIdentifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousSucceedsIf = AST.Token.Token "succeeds_if" 40

type AnonymousTo = AST.Token.Token "to" 53

type AnonymousTrue = AST.Token.Token "true" 113

data TypeIdentifier a = TypeIdentifier {ann :: a, text :: Data.Text.Internal.Text}

data TypeParameterIdentifier a = TypeParameterIdentifier
  { ann :: a
  , text :: Data.Text.Internal.Text
  }

type AnonymousU128 = AST.Token.Token "u128" 64

type AnonymousU16 = AST.Token.Token "u16" 61

type AnonymousU256 = AST.Token.Token "u256" 65

type AnonymousU32 = AST.Token.Token "u32" 62

type AnonymousU64 = AST.Token.Token "u64" 63

type AnonymousU8 = AST.Token.Token "u8" 60

type AnonymousUse = AST.Token.Token "use" 3

data VariableIdentifier a = VariableIdentifier {ann :: a, text :: Data.Text.Internal.Text}

data VariantIdentifier a = VariantIdentifier {ann :: a, text :: Data.Text.Internal.Text}

type AnonymousVectorLAngle = AST.Token.Token "vector<" 81

type AnonymousVectorLBracket = AST.Token.Token "vector[" 80

type AnonymousWhere = AST.Token.Token "where" 82

type AnonymousWhile = AST.Token.Token "while" 86

type AnonymousWith = AST.Token.Token "with" 43

type AnonymousLBrace = AST.Token.Token "{" 9

type AnonymousPipe = AST.Token.Token "|" 76

type AnonymousRBrace = AST.Token.Token "}" 11
