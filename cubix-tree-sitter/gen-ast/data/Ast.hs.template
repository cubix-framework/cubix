-- WARNING: This module was generated by `tree-sitter-generate-ast`.
--
-- build-depends:
--   , base          >=4.13 && <5
--   , bytestring    >=0.11 && <0.13
--   , containers    >=0.6  && <0.8
--   , mtl           >=2.3  && <2.4
{-+}
${if(pretty)}
--   , prettyprinter >=1.7  && <1.8
${endif}
{+-}
--   , transformers  >=0.6  && <0.7
--   , tree-sitter
--
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

{-+}
module ${moduleName} (
{+-}
  Label (..),
  LabelSing (..),
  decLabelSing,
  SymbolType (..),
  SymbolTypeSing (..),
  decSymbolTypeSing,
  Symbol (..),
  SymbolSing (..),
  decSymbolSing,
  symbolToSymbolType,
  SymbolToLabel,
  symbolToLabel,
  SomeSymbolSing (..),
  SymbolTable,
  mkSymbolTable,
  type (:<) (..),
  Node (
{-+}
${for(dataTypes)}
${for(it.constrs)}
    ${it.name.camelCase},
${endfor}${endfor}
{+-}
    Error,
    Missing,
    SortMismatch
  ),
  nodeToNodeId,
  nodeToRange,
  nodeToChildren,
  SomeNode (..),
  someNodeToNodeId,
  someNodeToRange,
  someNodeToChildren,
  NodeContent (..),
  nodeContentToSymbol,
  Children (..),
  ChildList (..),
  Ast,
  AstCache,
  parseAst,
  checkSort,
) where

import Control.Applicative (Alternative (..), optional)
import Control.Monad (MonadPlus (..))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader, ReaderT (..), asks)
import Control.Monad.State.Strict (MonadState (..), StateT (..), gets, modify')
import Control.Monad.Trans.Maybe (MaybeT (..))
import Data.ByteString.Char8 qualified as BSC
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Kind (Type)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Maybe (isJust)
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
{-+}
${if(pretty)}
import Prettyprinter (Doc, Pretty (..), nest, parens, sep)
${endif}
{+-}
import TreeSitter (NodeId (..), Range (..))
import TreeSitter qualified as TS

import Data.Comp.Multi.Kinds (type Sort)

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

{-+}
type Ast = Node ${startSort.camelCase}L
{+-}

parseAst :: SymbolTable -> TS.Tree -> AstCache -> IO (Maybe (Ast, AstCache))
parseAst symbolTable tree astCache = do
  rootNode <- TS.treeRootNode tree
  treeCursor <- TS.treeCursorNew rootNode
  let pEnv = PEnv symbolTable treeCursor astCache
  let pState = PState rootNode mempty
  (maybeNode, pState') <- runStateT (runReaderT (runMaybeT (unP p)) pEnv) pState
  pure $ (,newCache pState') <$> maybeNode

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

type data Label :: Sort where
{-+}
${for(dataTypes)}
  ${it.name.camelCase}L :: Label
${endfor}
{+-}

data LabelSing (sort :: Label) where
{-+}
${for(dataTypes)}
  S${it.name.camelCase}L :: LabelSing ${it.name.camelCase}L
${endfor}
{+-}

deriving instance Eq (LabelSing sort)

deriving instance Show (LabelSing sort)

decLabelSing :: LabelSing sort1 -> LabelSing sort2 -> Maybe (sort1 :~: sort2)
{-+}
${for(dataTypes)}
decLabelSing S${it.name.camelCase}L S${it.name.camelCase}L = Just Refl
${endfor}
{+-}
decLabelSing _ _ = Nothing

class KnownLabel sort where
  labelSing :: LabelSing sort

{-+}
${for(dataTypes)}
instance KnownLabel ${it.name.camelCase}L where
  labelSing :: LabelSing ${it.name.camelCase}L
  labelSing = S${it.name.camelCase}L

${endfor}
{+-}

--------------------------------------------------------------------------------
-- SymbolType
--------------------------------------------------------------------------------

type data SymbolType where
  Regular :: SymbolType
  Auxiliary :: SymbolType
  Virtual :: SymbolType

data SymbolTypeSing (symbolType :: SymbolType) where
  SRegular :: SymbolTypeSing Regular
  SAuxiliary :: SymbolTypeSing Auxiliary
  SVirtual :: SymbolTypeSing Virtual

deriving instance Eq (SymbolTypeSing symbolType)

deriving instance Show (SymbolTypeSing symbolType)

decSymbolTypeSing :: SymbolTypeSing symbolType1 -> SymbolTypeSing symbolType2 -> Maybe (symbolType1 :~: symbolType2)
decSymbolTypeSing SRegular SRegular = Just Refl
decSymbolTypeSing SAuxiliary SAuxiliary = Just Refl
decSymbolTypeSing SVirtual SVirtual = Just Refl
decSymbolTypeSing _ _ = Nothing

data IsReal (symbolType :: SymbolType) where
  RegularIsReal :: IsReal Regular
  AuxiliaryIsReal :: IsReal Auxiliary

deriving instance Eq (IsReal symbolType)

deriving instance Show (IsReal symbolType)

symbolTypeIsReal :: SymbolTypeSing symbolType -> Either (IsReal symbolType) (symbolType :~: Virtual)
symbolTypeIsReal = \case
  SRegular -> Left RegularIsReal
  SAuxiliary -> Left AuxiliaryIsReal
  SVirtual -> Right Refl

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

type data Symbol (symbolType :: SymbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Symbol :: (symbolType ~ Regular) => Symbol symbolType
${endfor}
${endfor}
{+-}
  ErrorSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  MissingSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  SortMismatchSymbol :: (symbolType ~ Virtual) => Symbol symbolType

data SymbolSing (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol :: SymbolSing Regular ${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  SErrorSymbol :: SymbolSing Auxiliary ErrorSymbol
  SMissingSymbol :: SymbolSing Auxiliary MissingSymbol
  SSortMismatchSymbol :: SymbolSing Virtual SortMismatchSymbol

deriving instance Eq (SymbolSing sort symbol)

deriving instance Show (SymbolSing sort symbol)

decSymbolSing :: SymbolSing symbolType1 symbol1 -> SymbolSing symbolType2 symbol2 -> Maybe (symbolType1 :~: symbolType2, symbol1 :~~: symbol2)
{-+}
${for(dataTypes)}
${for(it.constrs)}
decSymbolSing S${it.name.camelCase}Symbol S${it.name.camelCase}Symbol = Just (Refl, HRefl)
${endfor}
${endfor}
{+-}
decSymbolSing SErrorSymbol SErrorSymbol = Just (Refl, HRefl)
decSymbolSing SMissingSymbol SMissingSymbol = Just (Refl, HRefl)
decSymbolSing SSortMismatchSymbol SSortMismatchSymbol = Just (Refl, HRefl)
decSymbolSing _ _ = Nothing

data SomeSymbolSing
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeSymbolSing !(IsReal symbolType) !(SymbolSing symbolType symbol)

instance Eq SomeSymbolSing where
  (==) :: SomeSymbolSing -> SomeSymbolSing -> Bool
  SomeSymbolSing _isReal1 symbolSing1 == SomeSymbolSing _isReal2 symbolSing2 =
    isJust (decSymbolSing symbolSing1 symbolSing2)

deriving instance Show SomeSymbolSing

pattern SomeRegularSymbolSing :: () => (symbolType ~ Regular) => SymbolSing symbolType symbol -> SomeSymbolSing
pattern SomeRegularSymbolSing symbolSing = SomeSymbolSing RegularIsReal symbolSing

pattern SomeAuxiliarySymbolSing :: () => (symbolType ~ Auxiliary) => SymbolSing symbolType symbol -> SomeSymbolSing
pattern SomeAuxiliarySymbolSing symbolSing = SomeSymbolSing AuxiliaryIsReal symbolSing

--------------------------------------------------------------------------------
-- Getting the symbol types for symbols
--------------------------------------------------------------------------------

symbolToSymbolType :: SymbolSing symbolType symbol -> SymbolTypeSing symbolType
symbolToSymbolType = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> SRegular
${endfor}
${endfor}
{+-}
  SErrorSymbol -> SAuxiliary
  SMissingSymbol -> SAuxiliary
  SSortMismatchSymbol -> SVirtual

--------------------------------------------------------------------------------
-- Inferring sorts for regular symbols
--------------------------------------------------------------------------------

type family SymbolToLabel (symbol :: Symbol Regular) :: Label where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  SymbolToLabel ${it.name.camelCase}Symbol = ${it.sort.camelCase}L
${endfor}
${endfor}
{+-}

symbolToLabel :: SymbolSing Regular symbol -> LabelSing (SymbolToLabel symbol)
symbolToLabel = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> S${it.sort.camelCase}L
${endfor}
${endfor}
{+-}

--------------------------------------------------------------------------------
-- Well-sortedness for symbols
--------------------------------------------------------------------------------

type (:<) :: forall (symbolType :: SymbolType). Symbol symbolType -> Label -> Type
data (:<) symbol sort where
  RegularWellSorted ::
    forall (symbol :: Symbol Regular) (sort :: Label).
    {-# UNPACK #-} !(SymbolToLabel symbol :~: sort) ->
    symbol :< sort
  AuxiliaryWellSorted ::
    forall (symbol :: Symbol Auxiliary) (sort :: Label).
    symbol :< sort
  VirtualWellSorted ::
    forall (symbol :: Symbol Virtual) (sort :: Label).
    symbol :< sort

deriving instance Eq (symbol :< sort)

deriving instance Show (symbol :< sort)

--------------------------------------------------------------------------------
-- Nodes
--------------------------------------------------------------------------------

data Node (sort :: Label)
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    Node !(symbol :< sort) !(NodeContent symbolType symbol)

instance Eq (Node sort) where
  (==) :: Node sort -> Node sort -> Bool
  Node isWellSorted1 content1 == Node isWellSorted2 content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> isWellSorted1 == isWellSorted2 && content1 == content2

nodeToNodeId :: Node sort -> NodeId
nodeToNodeId = someNodeToNodeId . nodeToSomeNode

nodeToRange :: Node sort -> Range
nodeToRange = someNodeToRange . nodeToSomeNode

nodeToChildren :: Node sort -> [SomeNode]
nodeToChildren = getChildren

data SomeNode
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeNode !(IsReal symbolType) !(NodeContent symbolType symbol)

instance Eq SomeNode where
  (==) :: SomeNode -> SomeNode -> Bool
  SomeNode _isReal1 content1 == SomeNode _isReal2 content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> content1 == content2

deriving instance Show SomeNode

someNodeToNodeId :: SomeNode -> NodeId
someNodeToNodeId (SomeNode isReal content) = nodeContentToNodeId isReal content

someNodeToRange :: SomeNode -> Range
someNodeToRange (SomeNode isReal content) = nodeContentToRange isReal content

someNodeToChildren :: SomeNode -> [SomeNode]
someNodeToChildren = getChildren

nodeToSomeNode :: Node sort -> SomeNode
nodeToSomeNode (Node _isWellSorted content) =
  case symbolTypeIsReal (symbolToSymbolType (nodeContentToSymbol content)) of
    Left isReal -> SomeNode isReal content
    Right Refl -> let SortMismatchContent someNode = content in someNode

data NodeContent (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
${if(it.hasChildren)}
    !(Children '[${for(it.fields)}${it.type}${sep}, ${endfor}]) ->
${endif}
    NodeContent Regular ${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  ErrorContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[[SomeNode]]) ->
    NodeContent Auxiliary ErrorSymbol
  MissingContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    NodeContent Auxiliary MissingSymbol
  SortMismatchContent ::
    !SomeNode ->
    NodeContent Virtual SortMismatchSymbol

deriving instance Eq (NodeContent symbolType symbol)

deriving instance Show (NodeContent symbolType symbol)

nodeContentToSymbol ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  NodeContent symbolType symbol ->
  SymbolSing symbolType symbol
nodeContentToSymbol = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content{} -> S${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  ErrorContent{} -> SErrorSymbol
  MissingContent{} -> SMissingSymbol
  SortMismatchContent{} -> SSortMismatchSymbol

nodeContentToNodeId ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  IsReal symbolType ->
  NodeContent symbolType symbol ->
  NodeId
nodeContentToNodeId RegularIsReal = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content nodeId _range${if(it.hasChildren)} _children${endif} -> nodeId
${endfor}
${endfor}
{+-}
nodeContentToNodeId AuxiliaryIsReal = \case
  ErrorContent nodeId _range _children -> nodeId
  MissingContent nodeId _range -> nodeId

nodeContentToRange ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  IsReal symbolType ->
  NodeContent symbolType symbol ->
  Range
nodeContentToRange RegularIsReal = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content _nodeId range${if(it.hasChildren)} _children${endif} -> range
${endfor}
${endfor}
{+-}
nodeContentToRange AuxiliaryIsReal = \case
  ErrorContent _nodeId range _children -> range
  MissingContent _nodeId range -> range

--------------------------------------------------------------------------------
-- Node Children as Heterogeneous Lists
--------------------------------------------------------------------------------

data ChildList (as :: [Type]) :: Type where
  Nil :: ChildList '[]
  Cons :: !a -> !(ChildList as) -> ChildList (a ': as)

deriving instance Eq (ChildList '[])

deriving instance Show (ChildList '[])

deriving instance (Eq a, Eq (ChildList as)) => Eq (ChildList (a ': as))

deriving instance (Show a, Show (ChildList as)) => Show (ChildList (a ': as))

newtype Children as = Children (ChildList as)

deriving instance (Eq (ChildList as)) => Eq (Children as)

deriving instance (Show (ChildList as)) => Show (Children as)

--------------------------------------------------------------------------------
-- Check Sort
--------------------------------------------------------------------------------

checkSort ::
  LabelSing sort ->
  SomeNode ->
  Maybe (Node sort)
checkSort sort (SomeNode _isReal content) = do
  let symbol = nodeContentToSymbol content
  let symbolType = symbolToSymbolType symbol
  case symbolType of
    SRegular ->
      case decLabelSing sort (symbolToLabel symbol) of
        Just Refl -> pure $ Node (RegularWellSorted Refl) content
        Nothing -> Nothing
    SAuxiliary -> pure $ Node AuxiliaryWellSorted content

--------------------------------------------------------------------------------
-- Difference Lists
--------------------------------------------------------------------------------

newtype DList a = DList ([a] -> [a])

instance Semigroup (DList a) where
  (<>) :: DList a -> DList a -> DList a
  DList xs <> DList ys = DList (xs . ys)

instance Monoid (DList a) where
  mempty :: DList a
  mempty = DList id

instance Functor DList where
  fmap :: (a -> b) -> DList a -> DList b
  fmap f = foldMap (singleton . f)

instance Foldable DList where
  foldMap :: (Monoid m) => (a -> m) -> DList a -> m
  foldMap f = foldMap f . toList

singleton :: a -> DList a
singleton x = DList (x :)

toList :: DList a -> [a]
toList (DList xs) = xs []

--------------------------------------------------------------------------------
-- Node Children as Lists
--------------------------------------------------------------------------------

{-# SPECIALIZE getChildren :: Node sort -> [SomeNode] #-}
{-# SPECIALIZE getChildren :: SomeNode -> [SomeNode] #-}
getChildren :: (HasNodes a) => a -> [SomeNode]
getChildren = toList . foldMap getNodesDList . getNodesDList

{-# SPECIALIZE getNodes :: Node sort -> [SomeNode] #-}
{-# SPECIALIZE getNodes :: SomeNode -> [SomeNode] #-}
getNodes :: (HasNodes a) => a -> [SomeNode]
getNodes = toList . getNodesDList

class HasNodes a where
  getNodesDList :: a -> DList SomeNode

instance HasNodes (ChildList '[]) where
  getNodesDList :: ChildList '[] -> DList SomeNode
  getNodesDList Nil = mempty

instance (HasNodes a, HasNodes (ChildList as)) => HasNodes (ChildList (a ': as)) where
  getNodesDList :: ChildList (a ': as) -> DList SomeNode
  getNodesDList (Cons x xs) = getNodesDList x <> getNodesDList xs

instance (HasNodes (ChildList as)) => HasNodes (Children as) where
  getNodesDList :: Children as -> DList SomeNode
  getNodesDList (Children xs) = getNodesDList xs

instance HasNodes () where
  getNodesDList :: () -> DList SomeNode
  getNodesDList () = mempty

instance {-# OVERLAPPING #-} (HasNodes a, HasNodes b) => HasNodes (a, b) where
  getNodesDList :: (a, b) -> DList SomeNode
  getNodesDList (x, y) = getNodesDList x <> getNodesDList y

instance {-# OVERLAPPING #-} (HasNodes a, HasNodes b) => HasNodes (Either a b) where
  getNodesDList :: Either a b -> DList SomeNode
  getNodesDList = either getNodesDList getNodesDList

instance (Foldable t, HasNodes a) => HasNodes (t a) where
  getNodesDList :: t a -> DList SomeNode
  getNodesDList = foldMap getNodesDList

instance HasNodes (Node sort) where
  getNodesDList :: Node sort -> DList SomeNode
  getNodesDList = getNodesDList . nodeToSomeNode

instance HasNodes SomeNode where
  getNodesDList :: SomeNode -> DList SomeNode
  getNodesDList = singleton

instance HasNodes (NodeContent symbolType symbol) where
  getNodesDList :: NodeContent symbolType symbol -> DList SomeNode
  getNodesDList = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
    ${it.name.camelCase}Content _nodeId _range${if(it.hasChildren)} _children${endif} -> ${if(it.hasChildren)}getNodesDList _children${else}mempty${endif}
${endfor}
${endfor}
{+-}
    ErrorContent _nodeId _range _children -> getNodesDList _children
    MissingContent _nodeId _range -> mempty
    SortMismatchContent _children -> getNodesDList _children

--------------------------------------------------------------------------------
-- Pattern Synonyms
--------------------------------------------------------------------------------

{-+}
${for(dataTypes)}
${for(it.constrs)}
pattern ${it.name.camelCase} :: () => (sort ~ ${it.sort.camelCase}L) => NodeId -> Range -> ${if(it.hasChildren)}${for(it.fields)}${it.type} -> ${endfor}${endif}Node sort
pattern ${it.name.camelCase} nodeId range${if(it.hasChildren)}${for(it.fields)} nodeChild${it.index}${endfor}${endif} =
  Node (RegularWellSorted Refl) (${it.name.camelCase}Content nodeId range${if(it.hasChildren)} (Children${for(it.fields)} (Cons nodeChild${it.index}${endfor} Nil${for(it.fields)})${endfor})${endif})

${endfor}
${endfor}
{+-}

pattern Error :: NodeId -> Range -> [SomeNode] -> Node sort
pattern Error nodeId range nodeChild0 =
  Node AuxiliaryWellSorted (ErrorContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern Missing :: NodeId -> Range -> Node sort
pattern Missing nodeId range =
  Node AuxiliaryWellSorted (MissingContent nodeId range)

pattern SortMismatch :: SomeNode -> Node sort
pattern SortMismatch nodeChild0 =
  Node VirtualWellSorted (SortMismatchContent nodeChild0)

{-# COMPLETE
{-+}
${for(dataTypes/first)}
${for(it.constrs/first)}
  ${it.name.camelCase}
${endfor}
${for(it.constrs/rest)}
  , ${it.name.camelCase}
${endfor}
${endfor}
${for(dataTypes/rest)}
${for(it.constrs)}
  , ${it.name.camelCase}
${endfor}
${endfor}
{+-}
  , Error
  , Missing
  , SortMismatch
  #-}

--------------------------------------------------------------------------------
-- Show Instance using Pattern Synonyms
--------------------------------------------------------------------------------

instance Show (Node sort) where
  showsPrec :: Int -> Node sort -> ShowS
  showsPrec prec =
    showParen (prec > 10) . \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
      ${it.name.camelCase} nodeId range${if(it.hasChildren)}${for(it.fields)} nodeChild${it.index}${endfor}${endif} ->
        showString "${it.name.camelCase} " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range ${if(it.hasChildren)}${for(it.fields)} . showChar ' ' . showsPrec 11 nodeChild${it.index}${endfor}${endif}
${endfor}
${endfor}
{+-}
      Error nodeId range nodeChild0 ->
        showString "Error " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      Missing nodeId range ->
        showString "Missing " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range
      SortMismatch nodeChild0 ->
        showString "SortMismatch " . showsPrec 11 nodeChild0

--------------------------------------------------------------------------------
-- Symbol Table
--------------------------------------------------------------------------------

newtype SymbolTable = SymbolTable {unSymbolTable :: IntMap SomeSymbolSing}

mkSymbolTable :: TS.Language -> IO SymbolTable
mkSymbolTable language =
  fmap (SymbolTable . IM.fromList) . sequence $
{-+}
${for(dataTypes/first)}
${for(it.constrs/first)}
    [ mkEntry "${it.name.text}" (SomeRegularSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${for(it.constrs/rest)}
    , mkEntry "${it.name.text}" (SomeRegularSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${endfor}
${for(dataTypes/rest)}
${for(it.constrs)}
    , mkEntry "${it.name.text}" (SomeRegularSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${endfor}
{+-}
    ]
 where
  mkEntry :: String -> SomeSymbolSing -> IO (Int, SomeSymbolSing)
  mkEntry grammarType someSymbol = do
    (,someSymbol) . fromIntegral <$> TS.languageSymbolForGrammarType language (BSC.pack grammarType) True

--------------------------------------------------------------------------------
-- Node Cache
--------------------------------------------------------------------------------

newtype AstCache = AstCache {unAstCache :: IntMap SomeNode}
  deriving (Show, Semigroup, Monoid)

--------------------------------------------------------------------------------
-- Parser Monad
--------------------------------------------------------------------------------

data PState = PState
  { currentNode :: {-# UNPACK #-} !TS.Node
  , newCache :: {-# NOUNPACK #-} !AstCache
  }

data PEnv = PEnv
  { symbolTable :: {-# UNPACK #-} !SymbolTable
  , treeCursor :: {-# UNPACK #-} !TS.TreeCursor
  , oldCache :: {-# UNPACK #-} !AstCache
  }

newtype P a = P {unP :: MaybeT (ReaderT PEnv (StateT PState IO)) a}
  deriving (Functor, Applicative, Monad, MonadIO, MonadReader PEnv, MonadState PState, Alternative, MonadPlus)

getCurrentNode :: P TS.Node
getCurrentNode = gets currentNode

putCurrentNode :: TS.Node -> P ()
putCurrentNode node = modify' (\pstate -> pstate{currentNode = node})

getSymbol :: TS.Node -> P SomeSymbolSing
getSymbol node = do
  currentNodeIsError <- liftIO (TS.nodeIsError node)
  if currentNodeIsError
    then pure (SomeAuxiliarySymbolSing SErrorSymbol)
    else do
      currentNodeIsMissing <- liftIO (TS.nodeIsMissing node)
      if currentNodeIsMissing
        then pure (SomeAuxiliarySymbolSing SMissingSymbol)
        else do
          symbol <- liftIO (TS.nodeSymbol node)
          asks ((IM.! fromIntegral symbol) . unSymbolTable . symbolTable)

cacheSomeNode :: SomeNode -> P SomeNode
cacheSomeNode someNode = modify' updatePState >> pure someNode
 where
  nodeId = someNodeToNodeId someNode
  updateAstCache = AstCache . IM.insert (unWrapTSNodeId nodeId) someNode . unAstCache
  updatePState pstate = pstate{newCache = updateAstCache (newCache pstate)}

findOldSomeNodeInCache :: P SomeNode
findOldSomeNodeInCache =
  gets (TS.nodeId . currentNode) >>= \nodeId -> do
    asks (IM.lookup (unWrapTSNodeId nodeId) . unAstCache . oldCache)
      >>= maybe mzero pure

gotoParent :: P ()
gotoParent = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoParent treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      putCurrentNode currentNode

gotoFirstNamedChild :: P ()
gotoFirstNamedChild = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoFirstChild treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

gotoNextNamedSibling :: P ()
gotoNextNamedSibling = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoNextSibling treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

--------------------------------------------------------------------------------
-- Parser Class
--------------------------------------------------------------------------------

class HasParser a where
  p :: P a

instance HasParser NodeId where
  p :: P NodeId
  p = TS.nodeId <$> getCurrentNode

instance HasParser (ChildList '[]) where
  p :: P (ChildList '[])
  p = pure Nil

instance (HasParser a) => HasParser (ChildList (a ': '[])) where
  p :: P (ChildList '[a])
  p = Cons <$> p <*> pure Nil

instance (HasParser a, HasParser (ChildList (b ': bs))) => HasParser (ChildList (a ': b ': bs)) where
  p :: P (ChildList (a ': b ': bs))
  p = Cons <$> p <* gotoNextNamedSibling <*> p

instance (HasParser (ChildList as)) => HasParser (Children as) where
  p :: P (Children as)
  p = Children <$> (gotoFirstNamedChild *> p <* gotoParent)

instance (HasParser a) => HasParser (Maybe a) where
  p :: P (Maybe a)
  p = optional p

instance (HasParser a) => HasParser [a] where
  p :: P [a]
  p = pPostFence p gotoNextNamedSibling

instance (HasParser a) => HasParser (NonEmpty a) where
  p :: P (NonEmpty a)
  p = pPostFence1 p gotoNextNamedSibling

instance HasParser Range where
  p :: P Range
  p = liftIO . TS.nodeRange =<< getCurrentNode

pPostFence :: P a -> P () -> P [a]
pPostFence post fence = postFence
 where
  fencePost = fence *> postFence <|> pure []
  postFence = ((:) <$> post <*> fencePost) <|> pure []

pPostFence1 :: P a -> P () -> P (NonEmpty a)
pPostFence1 post fence = postFence
 where
  fencePost = fence *> pPostFence post fence <|> pure []
  postFence = (:|) <$> post <*> fencePost

--------------------------------------------------------------------------------
-- Node Parser
--------------------------------------------------------------------------------

instance (KnownLabel sort) => HasParser (Node sort) where
  p :: P (Node sort)
  p = pNode

pNode :: (KnownLabel sort) => P (Node sort)
pNode =
  pSomeNode >>= \someNode@(SomeNode isReal content) -> do
    let symbol = nodeContentToSymbol content
    case isReal of
      RegularIsReal ->
        pure $
          case decLabelSing (symbolToLabel symbol) labelSing of
            Just prf -> Node (RegularWellSorted prf) content
            Nothing -> SortMismatch someNode
      AuxiliaryIsReal -> pure $ Node AuxiliaryWellSorted content

instance HasParser SomeNode where
  p :: P SomeNode
  p = pSomeNode

pSomeNode :: P SomeNode
pSomeNode = cacheSomeNode =<< pSomeNode' =<< getCurrentNode
 where
  pSomeNode' :: TS.Node -> P SomeNode
  pSomeNode' node = tryCache <|> tryParse
   where
    tryCache = do
      liftIO (TS.nodeHasChanges node) >>= \nodeHasChanges ->
        if nodeHasChanges then mzero else findOldSomeNodeInCache
    tryParse = do
      getSymbol node >>= \(SomeSymbolSing isReal symbol) ->
        SomeNode isReal <$> pNodeContent symbol

pNodeContent :: SymbolSing symbolType symbol -> P (NodeContent symbolType symbol)
pNodeContent = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> ${it.name.camelCase}Content <$$> p <*> p${if(it.hasChildren)} <*> p${endif}
${endfor}
${endfor}
{+-}
  SErrorSymbol -> ErrorContent <$> p <*> p <*> p
  SMissingSymbol -> MissingContent <$> p <*> p
  SSortMismatchSymbol -> SortMismatchContent <$> p
{-+}
${if(pretty)}

--------------------------------------------------------------------------------
-- Pretty Printing
--------------------------------------------------------------------------------

instance Pretty SomeNode where
  pretty :: SomeNode -> Doc ann
  pretty (SomeNode _isReal content) = pretty content

instance Pretty (Node sort) where
  pretty :: Node sort -> Doc ann
  pretty (Node _isWellSorted content) = pretty content

instance Pretty (NodeContent symbolType symbol) where
  pretty :: NodeContent symbolType symbol -> Doc ann
  pretty content = prettySList (pretty (nodeContentToSymbol content) : fmap pretty (getNodes content))

prettySList :: [Doc ann] -> Doc ann
prettySList = parens . nest 2 . sep

instance Pretty (SymbolSing symbolType symbol) where
  pretty :: SymbolSing symbolType symbol -> Doc ann
  pretty = \case
${for(dataTypes)}
${for(it.constrs)}
    S${it.name.camelCase}Symbol -> "${it.name.text}"
${endfor}
${endfor}
    SErrorSymbol -> "ERROR"
    SMissingSymbol -> "MISSING"
    SSortMismatchSymbol -> "SORT_MISMATCH"
${endif}
{+-}
