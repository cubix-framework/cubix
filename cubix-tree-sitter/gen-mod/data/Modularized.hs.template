{-# LANGUAGE TypeData #-}
{-# LANGUAGE TemplateHaskell #-}

{-+}
module ${moduleName}
{+-}
  where

import Data.Comp.Multi.Strategy.Classification (DynCase (..))
import Data.Text (Text)
import Data.Type.Equality (type (:~:) (..))
import Language.Haskell.TH qualified as TH

import Cubix.Language.Info (TermLab)
import Cubix.Language.Parametric.Derive
import Cubix.Language.Parametric.Syntax qualified as Syntax
import Cubix.ParsePretty (type RootSort)
import Data.Comp.Multi (Term, project)

--------------------------------------------------------------------------------
-- Labels
--------------------------------------------------------------------------------

{-+}
${for(labels)}
data ${it.sort}
${endfor}
{+-}

{-+}
${for(tokens)}
data ${it.name.sort}
${endfor}
{+-}

--------------------------------------------------------------------------------
-- Modularized syntax
--------------------------------------------------------------------------------

data Token e l where
{-+}
${for(tokens)}
  ${it.name.camelCase} :: Token e ${it.name.sort}
${endfor}
{+-}

deriveAllButDynCase [''Token]

{-+}
${for(data)}
data ${it.name.camelCase} e l where
${for(it.constructors)}
  ${it.name.camelCase}
    :: ${if(it.hasChildren)}${for(it.fields)}${it.type}
    -> ${endfor}${endif}${data.name.camelCase} e ${it.type.sort}
${endfor}

${endfor}
{+-}

{-+}
deriveAll
${for(data/first)}
  [ ''${it.name.camelCase/first}
${endfor}
${for(data/rest)}
  , ''${it.name.camelCase}
${endfor}
  ]
{+-}

--------------------------------------------------------------------------------
-- Signature
--------------------------------------------------------------------------------

{-+}
type ${grammarName}Sig =
${for(data/first)}
  '[ ${it.name.camelCase}
${endfor}
${for(data/rest)}
   , ${it.name.camelCase}
${endfor}
   , Token
   , Syntax.PairF
   , Syntax.MaybeF
   , Syntax.ListF
   ]

type ${grammarName}Term      = Term ${grammarName}Sig
type ${grammarName}TermLab l = TermLab ${grammarName}Sig l
{+-}

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

{-+}
type instance RootSort ${grammarName}Sig = ${startSort.sort}
{+-}

--------------------------------------------------------------------------------
-- Signature TH Names
--------------------------------------------------------------------------------

{-+}
${grammarName/lowercase}SigNames :: [TH.Name]
${grammarName/lowercase}SigNames =
${for(data/first)}
   [ ''${it.name.camelCase}
${endfor}
${for(data/rest)}
   , ''${it.name.camelCase}
${endfor}
   , ''Token
   , ''Syntax.PairF
   , ''Syntax.MaybeF
   , ''Syntax.ListF
   ]
{+-}

--------------------------------------------------------------------------------
-- Generated instances
--------------------------------------------------------------------------------

{-+}
${for(tokens)}
instance {-# OVERLAPPING #-} DynCase MoveTerm ${it.name.sort} where
  dyncase (project -> Just ${it.name.camelCase}) = Just Refl
  dyncase _ = Nothing

${endfor}
{+-}
