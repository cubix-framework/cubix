-- WARNING: This module was generated by `tree-sitter-generate-ast`.
--
-- build-depends:
--   , base          >=4.13 && <5
--   , bytestring    >=0.11 && <0.13
--   , containers    >=0.6  && <0.8
--   , mtl           >=2.3  && <2.4
{-+}
${if(pretty)}
--   , prettyprinter >=1.7  && <1.8
${endif}
{+-}
--   , transformers  >=0.6  && <0.7
--   , tree-sitter
--
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

{-+}
module ${moduleName} (
{+-}
) where

import Control.Applicative (Alternative (..), optional)
import Control.Monad (MonadPlus (..))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader, ReaderT (..), asks)
import Control.Monad.State.Strict (MonadState (..), StateT (..), gets, modify')
import Control.Monad.Trans.Maybe (MaybeT (..))
import Data.ByteString.Char8 qualified as BSC
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Kind (Type)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Maybe (isJust)
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
{-+}
${if(pretty)}
import Prettyprinter (Doc, Pretty (..), nest, parens, sep)
${endif}
{+-}
import TreeSitter (NodeId (..), Range (..))
import TreeSitter qualified as TS

import Cubix.Language.Info (TermLab)
import Cubix.ParsePretty (type RootSort)
import Data.Comp.Multi (Term)
import Data.Comp.Multi.Kinds qualified as Kinds

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

type data Sort :: Kinds.Sort where
{-+}
${for(dataTypes)}
data ${it.name.camelCase}L
${endfor}
{+-}

--------------------------------------------------------------------------------
-- Modularized syntax
--------------------------------------------------------------------------------

{-+}
${for(dataTypes)}
data ${it.name.camelCase} e l where
${for(it.constrs)}
  ${it.name.camelCase}
    :: ${if(it.hasChildren)}${for(it.fields)}${it.type}
    -> ${endfor}${endif}${dataTypes.name.camelCase} e ${it.sort.camelCase}L
${endfor}

${endfor}
{+-}

--------------------------------------------------------------------------------
-- Signature
--------------------------------------------------------------------------------

{-+}
type ${grammarName}Sig =
  '[ ${for(dataTypes)}${it.name.camelCase}${sep}
   , ${endfor}
   ]

type ${grammarName}Term      = Term ${grammarName}Sig
type ${grammarName}TermLab l = TermLab ${grammarName}Sig l
{+-}

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

{-+}
type instance RootSort ${grammarName}Sig = ${startSort.camelCase}L
{+-}
