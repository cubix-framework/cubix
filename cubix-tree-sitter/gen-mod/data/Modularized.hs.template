{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

{-+}
module ${moduleName}
{+-}
  where

import Data.ByteString.Char8 qualified as BSC
import Data.Foldable (foldrM)
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Maybe (isJust)
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import TreeSitter qualified as TS

import Cubix.Language.Info (TermLab)
import Cubix.Language.Parametric.Derive
import Cubix.Language.Parametric.Syntax qualified as Syntax
import Cubix.ParsePretty (type RootSort)
import Data.Comp.Multi (Sort, Term)

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

{-+}
${for(dataTypes)}
data ${it.name.camelCase}L
${endfor}
{+-}

{-+}
${for(tokens)}
data ${it.name.camelCase}TokL
${endfor}

data LabelSing (sort :: Sort) where
${for(dataTypes)}
  S${it.name.camelCase}L :: LabelSing ${it.name.camelCase}L
${endfor}
${for(tokens)}
  S${it.name.camelCase}TokL :: LabelSing ${it.name.camelCase}TokL
${endfor}

deriving instance Eq (LabelSing sort)

deriving instance Show (LabelSing sort)

decLabelSing :: LabelSing sort1 -> LabelSing sort2 -> Maybe (sort1 :~: sort2)
${for(dataTypes)}
decLabelSing S${it.name.camelCase}L S${it.name.camelCase}L = Just Refl
${endfor}
${for(tokens)}
decLabelSing S${it.name.camelCase}TokL S${it.name.camelCase}TokL = Just Refl
${endfor}
decLabelSing _ _ = Nothing

--------------------------------------------------------------------------------
-- SymbolType
--------------------------------------------------------------------------------

type data SymbolType where
  Regular :: SymbolType
  Anonymous :: SymbolType
  Auxiliary :: SymbolType
  Virtual :: SymbolType

data SymbolTypeSing (symbolType :: SymbolType) where
  SRegular :: SymbolTypeSing Regular
  SAnonymous :: SymbolTypeSing Anonymous
  SAuxiliary :: SymbolTypeSing Auxiliary
  SVirtual :: SymbolTypeSing Virtual

deriving instance Eq (SymbolTypeSing symbolType)

deriving instance Show (SymbolTypeSing symbolType)

decSymbolTypeSing :: SymbolTypeSing symbolType1 -> SymbolTypeSing symbolType2 -> Maybe (symbolType1 :~: symbolType2)
decSymbolTypeSing SRegular SRegular = Just Refl
decSymbolTypeSing SAnonymous SAnonymous = Just Refl
decSymbolTypeSing SAuxiliary SAuxiliary = Just Refl
decSymbolTypeSing SVirtual SVirtual = Just Refl
decSymbolTypeSing _ _ = Nothing

data IsReal (symbolType :: SymbolType) where
  RegularIsReal :: IsReal Regular
  AnonymousIsReal :: IsReal Anonymous
  AuxiliaryIsReal :: IsReal Auxiliary

deriving instance Eq (IsReal symbolType)

deriving instance Show (IsReal symbolType)

symbolTypeIsReal :: SymbolTypeSing symbolType -> Either (IsReal symbolType) (symbolType :~: Virtual)
symbolTypeIsReal = \case
  SRegular -> Left RegularIsReal
  SAnonymous -> Left AnonymousIsReal
  SAuxiliary -> Left AuxiliaryIsReal
  SVirtual -> Right Refl

--------------------------------------------------------------------------------
-- Modularized syntax
--------------------------------------------------------------------------------

data Token e l where
${for(tokens)}
  ${it.name.camelCase} :: Token e ${it.name.camelCase}TokL
${endfor}
{+-}

deriveAll [''Token]

{-+}
${for(dataTypes)}
data ${it.name.camelCase} e l where
${for(it.constrs)}
  ${it.name.camelCase}
    :: ${if(it.hasChildren)}${for(it.fields)}${it.type}
    -> ${endfor}${endif}${dataTypes.name.camelCase} e ${it.sort.camelCase}L
${endfor}

${endfor}
{+-}

--------------------------------------------------------------------------------
-- Compdata derivation

{-+}
deriveAll
  [ ''${for(dataTypes)}${it.name.camelCase}${sep}
  , ''${endfor}
  ]
{+-}

--------------------------------------------------------------------------------
-- Signature
--------------------------------------------------------------------------------

{-+}
type ${grammarName}Sig =
  '[ ${for(dataTypes)}${it.name.camelCase}${sep}
   , ${endfor}
   , Token
   , Syntax.PairF
   , Syntax.MaybeF
   , Syntax.ListF
   , Syntax.EitherF
   , Syntax.UnitF
   ]

type ${grammarName}Term      = Term ${grammarName}Sig
type ${grammarName}TermLab l = TermLab ${grammarName}Sig l
{+-}

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

{-+}
type instance RootSort ${grammarName}Sig = ${startSort.camelCase}L
{+-}

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

type data Symbol (symbolType :: SymbolType) where
{-+}
${for(dataTypes)}
  ${it.name.camelCase}Symbol :: (symbolType ~ Regular) => Symbol symbolType
${endfor}
${for(tokens)}
  ${it.name.camelCase}TokSymbol :: (symbolType ~ Regular) => Symbol symbolType
${endfor}
{+-}
  ErrorSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  MissingSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  SortMismatchSymbol :: (symbolType ~ Virtual) => Symbol symbolType

data SymbolSing (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
{-+}
${for(dataTypes)}
  S${it.name.camelCase}Symbol :: SymbolSing Regular ${it.name.camelCase}Symbol
${endfor}
${for(tokens)}
  S${it.name.camelCase}TokSymbol :: SymbolSing Anonymous ${it.name.camelCase}TokSymbol
${endfor}
{+-}
  SErrorSymbol :: SymbolSing Auxiliary ErrorSymbol
  SMissingSymbol :: SymbolSing Auxiliary MissingSymbol
  SSortMismatchSymbol :: SymbolSing Virtual SortMismatchSymbol

deriving instance Eq (SymbolSing sort symbol)
deriving instance Ord (SymbolSing sort symbol)
deriving instance Show (SymbolSing sort symbol)

decSymbolSing :: SymbolSing symbolType1 symbol1 -> SymbolSing symbolType2 symbol2 -> Maybe (symbolType1 :~: symbolType2, symbol1 :~~: symbol2)
{-+}
${for(dataTypes)}
decSymbolSing S${it.name.camelCase}Symbol S${it.name.camelCase}Symbol = Just (Refl, HRefl)
${endfor}
${for(tokens)}
decSymbolSing S${it.name.camelCase}TokSymbol S${it.name.camelCase}TokSymbol = Just (Refl, HRefl)
${endfor}
{+-}
decSymbolSing SErrorSymbol SErrorSymbol = Just (Refl, HRefl)
decSymbolSing SMissingSymbol SMissingSymbol = Just (Refl, HRefl)
decSymbolSing SSortMismatchSymbol SSortMismatchSymbol = Just (Refl, HRefl)
decSymbolSing _ _ = Nothing

data SomeSymbolSing
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeSymbolSing !(IsReal symbolType) !(SymbolSing symbolType symbol)

instance Eq SomeSymbolSing where
  (==) :: SomeSymbolSing -> SomeSymbolSing -> Bool
  SomeSymbolSing _isReal1 symbolSing1 == SomeSymbolSing _isReal2 symbolSing2 =
    isJust (decSymbolSing symbolSing1 symbolSing2)

deriving instance Show SomeSymbolSing

pattern SomeRegularSymbolSing :: () => (symbolType ~ Regular) => SymbolSing symbolType symbol -> SomeSymbolSing
pattern SomeRegularSymbolSing symbolSing = SomeSymbolSing RegularIsReal symbolSing

pattern SomeAnonymousSymbolSing :: () => (symbolType ~ Anonymous) => SymbolSing symbolType symbol -> SomeSymbolSing
pattern SomeAnonymousSymbolSing symbolSing = SomeSymbolSing AnonymousIsReal symbolSing

pattern SomeAuxiliarySymbolSing :: () => (symbolType ~ Auxiliary) => SymbolSing symbolType symbol -> SomeSymbolSing
pattern SomeAuxiliarySymbolSing symbolSing = SomeSymbolSing AuxiliaryIsReal symbolSing

--------------------------------------------------------------------------------
-- Symbol Table
--------------------------------------------------------------------------------

newtype SymbolTable = SymbolTable {unSymbolTable :: IntMap SomeSymbolSing}

symbolMap :: Map String SomeSymbolSing
symbolMap = Map.fromList
{-+}
${for(dataTypes/first)}
    [ ("${it.name.text}", SomeRegularSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${for(dataTypes/rest)}
    , ("${it.name.text}", SomeRegularSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${for(tokens)}
    , ("${it.symbol}", SomeAnonymousSymbolSing S${it.name.camelCase}TokSymbol)
${endfor}
    ]
{+-}

mkSymbolTable :: TS.Language -> IO SymbolTable
mkSymbolTable lang = do
  count <- fromIntegral <$> TS.languageSymbolCount lang
  SymbolTable <$> foldrM
    (\id acc -> do
      symName <- TS.languageSymbolName lang id
      let mSymSing = Map.lookup (BSC.unpack symName) symbolMap
      pure (maybe acc (flip (IM.insert (fromIntegral id)) acc) mSymSing)
    )
    (IM.empty :: IntMap SomeSymbolSing)
    [0..count-1]
