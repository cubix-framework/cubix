{-# LANGUAGE OverloadedStrings #-}
{-+}
module ${moduleName} where
{+-}

import Control.Applicative.Combinators
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Reader (ReaderT, runReaderT)
import Data.Functor (($>))
import Data.List.NonEmpty (NonEmpty (..))
import Data.String (IsString (..))
import Data.Text
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import Data.Typeable (Typeable)
import Streaming.Prelude qualified as Streaming

import TreeSitter qualified as TS
import TreeSitter.SuiMove (tree_sitter_sui_move)
import Text.Megaparsec qualified as Megaparsec
import Text.Megaparsec.TreeSitter qualified as Megaparsec.TreeSitter
import Text.Megaparsec.Cubix qualified as Megaparsec.Cubix

import Cubix.Language.SuiMove.Modularized
import Cubix.TreeSitter

{-+}
parse' :: ReaderT (TreeSitterEnv SomeSymbolSing) IO (Maybe (${grammarName}Term (RootSort ${grammarName}Sig)))
{+-}
parse' = do
  filepath <- getFilePath
  rootNode <- liftIO . TS.treeRootNode =<< getTree
  toks <- Streaming.toList_
    $ Streaming.mapMaybeM
        (\tok ->
           fmap (\sym -> tok { tokenValue = sym }) <$> getSymbol (tokenValue tok))
    $ symbols filepath rootNode

  source <- getSource
  let lexed = Megaparsec.TreeSitter.Lexed source toks
  case Megaparsec.parse pRoot filepath lexed of
    Right ast -> pure $ Just ast
    Left err -> do
      liftIO . putStrLn $ Megaparsec.errorBundlePretty err
      pure Nothing

{-+}
parse :: FilePath -> IO (Maybe (${grammarName}Term (RootSort ${grammarName}Sig)))
{+-}
parse path =
  runReaderT parse' =<<
    newTreeSitterEnv path tree_sitter_sui_move (fmap unSymbolTable . mkSymbolTable)

-- --------------------------------------------------------------------------------
-- -- Parser 
-- --------------------------------------------------------------------------------
type SomeTerm = E ${grammarName}Term
type ${grammarName}Parser t = Parser NoHole (Sum ${grammarName}Sig) (K ()) t
type ${grammarName}TermParser l = ${grammarName}Parser (${grammarName}Term l)
type SomeTermParser = Parser (E ${grammarName}Term)

{-+}
${for(tokens)}
p${it.name.camelCase} :: TermParser ${it.name.sort}
p${it.name.camelCase} = pure ${it.name.camelCase}' <* Megaparsec.eof

${endfor}
{+-}

{-+}
${for(data)}
p${it.name.camelCase} :: TermParser ${it.name.sort}
p${it.name.camelCase} =
${if(it.sum)}
  choice [ Megaparsec.try ${for(it.constructors)}p${it.name.camelCase}${sep}
         , Megaparsec.try ${endfor}
         ]
${else}
${for(it.constructors)}
  ${if(it.hasChildren)}${else}pure ${endif}${it.name.camelCase}' <$$> ${it.parser}
${endfor}
${endif}
${if(it.sum)}
  where
${for(it.constructors)}
    p${it.name.camelCase} :: Parser (${grammarName}Term ${it.type.sort})
    p${it.name.camelCase} =
      ${if(it.hasChildren)}${else}pure ${endif}${it.name.camelCase}' <$$> ${it.parser}
${endfor}
${endif}

${endfor}
{+-}
