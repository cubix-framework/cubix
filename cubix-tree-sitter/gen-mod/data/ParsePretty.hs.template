{-+}
module ${moduleName} where
{+-}

import Control.Applicative.Combinators
import Control.Monad.IO.Class (MonadIO (..))
import Data.ByteString qualified as BS
import Data.IntMap.Strict qualified as IM
import Data.Functor (($>))
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import Data.Typeable (Typeable)
import Streaming.Prelude qualified as Streaming

import TreeSitter qualified as TS
import TreeSitter.SuiMove (tree_sitter_sui_move)
import Text.Megaparsec qualified as Megaparsec
import Text.Megaparsec.TreeSitter qualified as Megaparsec.TreeSitter
import Text.Megaparsec.Cubix qualified as Megaparsec.Cubix

import Cubix.ParsePretty
import Cubix.Language.SuiMove.Modularized
import Cubix.TreeSitter

getSymbol :: SymbolTable -> TS.Node -> IO (Maybe SomeSymbolSing)
getSymbol map node = do
  symbol <- TS.nodeSymbol node
  pure $ IM.lookup (fromIntegral symbol) (unSymbolTable map)

parse :: FilePath -> IO (Maybe (MoveTerm (RootSort MoveSig)))
parse path = do
  input <- BS.readFile path

  withLanguage tree_sitter_sui_move $ \lang -> do
    symbolTable <- liftIO (mkSymbolTable lang)

    withParser lang $ \parser -> do
      maybeTree <- TS.parserParseByteString parser Nothing input
      tree <- maybe (error "failed to parse the program") pure maybeTree
      rootNode <- TS.treeRootNode tree

      toks <- Streaming.toList_
        $ Streaming.mapMaybeM
            (\tok ->
              fmap (\sym -> tok { tokenValue = sym }) <$> getSymbol symbolTable (tokenValue tok))
              -- pure $ case msym of
              --   Just sym -> Just $ ann { tokenValue = sym }
              --   Nothing -> Nothing)
                                 
        $ annotated path rootNode

      let lexed = Megaparsec.TreeSitter.Lexed input toks
      case Megaparsec.parse pRoot path lexed of
        Right ast -> pure $ Just ast
        Left err -> do
          putStrLn $ Megaparsec.errorBundlePretty err
          pure Nothing

-- --------------------------------------------------------------------------------
-- -- Parser 
-- --------------------------------------------------------------------------------
type Parser = Megaparsec.TreeSitter.Parser SomeSymbolSing

pSymbol
  :: forall (symbolType :: SymbolType) (symbol :: Symbol symbolType)
   . SymbolSing symbolType symbol
  -> Parser (Cubix.TreeSitter.Token (SymbolSing symbolType symbol))
pSymbol sym = Megaparsec.TreeSitter.pToken $ \case
  SomeSymbolSing _isReal symSing -> case decSymbolSing sym symSing of
    Just (Refl, HRefl) -> Just symSing
    Nothing -> Nothing

-- reify the types to aid inference, that might get broken
pMaybe :: Typeable a => Parser (MoveTerm a) -> Parser (MoveTerm (Maybe a))
pMaybe = Megaparsec.Cubix.pMaybe

pPair :: (Typeable a, Typeable b) => Parser (MoveTerm a) -> Parser (MoveTerm b) -> Parser (MoveTerm (a , b))
pPair = Megaparsec.Cubix.pPair

pEither :: (Typeable a, Typeable b) => Parser (MoveTerm a) -> Parser (MoveTerm b) -> Parser (MoveTerm (Either a b))
pEither = Megaparsec.Cubix.pEither

pSome :: Typeable a => Parser (MoveTerm a) -> Parser (MoveTerm [a])
pSome = Megaparsec.Cubix.pSome

pMany :: Typeable a => Parser (MoveTerm a) -> Parser (MoveTerm [a])
pMany = Megaparsec.Cubix.pMany

{-+}
pRoot :: Parser (MoveTerm (RootSort MoveSig))
pRoot = p${startSort.camelCase}
{+-}

{-+}
${for(tokens)}
p${it.name.camelCase} :: Parser (MoveTerm ${it.name.camelCase}TokL)
p${it.name.camelCase} = pSymbol S${it.name.camelCase}TokSymbol $$> i${it.name.camelCase}

${endfor}
{+-}

{-+}
${for(dataTypes)}
p${it.name.camelCase} :: Parser (MoveTerm ${it.name.camelCase}L)
p${it.name.camelCase} = do${if(it.hidden)}${else}
  _sym <- pSymbol S${it.name.camelCase}Symbol${endif}
${if(it.isSum)}
  choice [ ${for(it.constrs)}p${it.name.camelCase}${sep}
         , ${endfor}
         ]
${else}
${for(it.constrs)}
  ${if(it.hasChildren)}${else}pure ${endif}i${it.name.camelCase}
${for(it.fields/first)}
    <$$> ${it.parser}
${endfor}
${for(it.fields/rest)}
    <*> ${it.parser}
${endfor}
${endfor}
${endif}
${if(it.isSum)}
  where
${for(it.constrs)}
    p${it.name.camelCase} :: Parser (MoveTerm ${it.sort.camelCase}L)
    p${it.name.camelCase} =
      ${if(it.hasChildren)}${else}pure ${endif}i${it.name.camelCase}
${for(it.fields/first)}
        <$$> ${it.parser}
${endfor}
${for(it.fields/rest)}
        <*> ${it.parser}
${endfor}
${endfor}
${endif}

${endfor}
{+-}
