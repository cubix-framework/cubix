{-# LANGUAGE OverloadedStrings #-}
{-+}
module ${moduleName} where
{+-}

import Control.Applicative.Combinators
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Reader (ReaderT, runReaderT)
import Data.Functor (($>))
import Data.List.NonEmpty (NonEmpty (..))
import Data.String (IsString (..))
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import Data.Typeable (Typeable)
import Streaming.Prelude qualified as Streaming

import TreeSitter qualified as TS
import TreeSitter.SuiMove (tree_sitter_sui_move)
import Text.Megaparsec qualified as Megaparsec
import Text.Megaparsec.TreeSitter qualified as Megaparsec.TreeSitter
import Text.Megaparsec.Cubix qualified as Megaparsec.Cubix

import Cubix.ParsePretty
import Cubix.Language.SuiMove.Modularized
import Cubix.TreeSitter

import Text.Pretty.Simple

parse' :: ReaderT (TreeSitterEnv SomeSymbolSing) IO (Maybe (MoveTerm (RootSort MoveSig)))
parse' = do
  filepath <- getFilePath
  rootNode <- liftIO . TS.treeRootNode =<< getTree
  toks <- Streaming.toList_
    $ Streaming.mapMaybeM
        (\tok ->
           fmap (\sym -> tok { tokenValue = sym }) <$> getSymbol (tokenValue tok))
    $ symbols filepath rootNode

  pPrintLightBg (tokenValue <$> toks)
  source <- getSource
  let lexed = Megaparsec.TreeSitter.Lexed source toks
  case Megaparsec.parse pRoot filepath lexed of
    Right ast -> pure $ Just ast
    Left err -> do
      liftIO . putStrLn $ Megaparsec.errorBundlePretty err
      pure Nothing

parse :: FilePath -> IO (Maybe (MoveTerm (RootSort MoveSig)))
parse path =
  runReaderT parse' =<<
    newTreeSitterEnv path tree_sitter_sui_move (fmap unSymbolTable . mkSymbolTable)

-- --------------------------------------------------------------------------------
-- -- Parser 
-- --------------------------------------------------------------------------------
type Parser = Megaparsec.TreeSitter.Parser SomeSymbolSing

instance IsString (NonEmpty Char) where
  fromString [] = error "NonEmpty.fromString: empty string"
  fromString (s:ss) = s :| ss

pSymbol
  :: forall (symbolType :: SymbolType) (symbol :: Symbol symbolType)
   . NonEmpty Char
  -> SymbolSing symbolType symbol
  -> Parser (Cubix.TreeSitter.Token (SymbolSing symbolType symbol))
pSymbol expected sym = Megaparsec.TreeSitter.pToken expected $ \case
  SomeSymbolSing _isReal symSing -> case decSymbolSing sym symSing of
    Just (Refl, HRefl) -> Just symSing
    Nothing -> Nothing

-- reify the types to aid inference, that might get broken
pMaybe :: Typeable a => Parser (MoveTerm a) -> Parser (MoveTerm (Maybe a))
pMaybe = Megaparsec.Cubix.pMaybe

pPair :: (Typeable a, Typeable b) => Parser (MoveTerm a) -> Parser (MoveTerm b) -> Parser (MoveTerm (a , b))
pPair = Megaparsec.Cubix.pPair

pEither :: (Typeable a, Typeable b) => Parser (MoveTerm a) -> Parser (MoveTerm b) -> Parser (MoveTerm (Either a b))
pEither = Megaparsec.Cubix.pEither

pSome :: Typeable a => Parser (MoveTerm a) -> Parser (MoveTerm [a])
pSome = Megaparsec.Cubix.pSome

pMany :: Typeable a => Parser (MoveTerm a) -> Parser (MoveTerm [a])
pMany = Megaparsec.Cubix.pMany

{-+}
pRoot :: Parser (MoveTerm (RootSort MoveSig))
pRoot = p${startSort.camelCase}
{+-}

{-+}
${for(tokens)}
p${it.name.camelCase} :: Parser (MoveTerm ${it.name.camelCase}TokL)
p${it.name.camelCase} = pSymbol "${it.name.text}" S${it.name.camelCase}TokSymbol $$> i${it.name.camelCase}

${endfor}
{+-}

{-+}
${for(dataTypes)}
p${it.name.camelCase} :: Parser (MoveTerm ${it.name.camelCase}L)
p${it.name.camelCase} = do${if(it.hidden)}${else}
  _sym <- pSymbol "${it.name.text}" S${it.name.camelCase}Symbol${endif}
${if(it.isSum)}
  choice [ ${for(it.constrs)}p${it.name.camelCase}${sep}
         , ${endfor}
         ]
${else}
${for(it.constrs)}
  ${if(it.hasChildren)}${else}pure ${endif}i${it.name.camelCase}
${for(it.fields/first)}
    <$$> ${it.parser}
${endfor}
${for(it.fields/rest)}
    <*> ${it.parser}
${endfor}
${endfor}
${endif}
${if(it.isSum)}
  where
${for(it.constrs)}
    p${it.name.camelCase} :: Parser (MoveTerm ${it.sort.camelCase}L)
    p${it.name.camelCase} =
      ${if(it.hasChildren)}${else}pure ${endif}i${it.name.camelCase}
${for(it.fields/first)}
        <$$> ${it.parser}
${endfor}
${for(it.fields/rest)}
        <*> ${it.parser}
${endfor}
${endfor}
${endif}

${endfor}
{+-}
