{-# LANGUAGE OverloadedStrings #-}
{-+}
module ${moduleName} where
{+-}

import Control.Applicative.Combinators
import Control.Monad ((<=<))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Reader (ReaderT, runReaderT)
import Data.ByteString (ByteString)
import Data.ByteString.Char8 qualified as Char8
import Data.Comp.Multi (E (..))
import Data.Comp.Multi.Strategy.Classification (DynCase)
import Data.Foldable (foldrM)
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.List.NonEmpty (NonEmpty)
import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Proxy (Proxy (..))
import Data.Text (Text)
import Data.Typeable (Typeable)

import TreeSitter qualified as TS
import TreeSitter.SuiMove (tree_sitter_sui_move)
import Text.Megaparsec qualified as Megaparsec
import Text.Megaparsec.Cubix qualified as Megaparsec.Cubix
-- import Text.Megaparsec.Cubix
--   ( pMaybe, pPair, pSome, pMany
--   , pSepBy, pSepBy1, pBetween
--   , pSort, pContent
--   )

import Cubix.TreeSitter
import Cubix.Language.SuiMove.Modularized

import Text.Pretty.Simple

parse' :: ReaderT TreeSitterEnv IO SomeTerm
parse' = do
  filepath <- getFilePath
  source <- getSource
  pTable <- liftIO . mkParseTable =<< getLanguage
  rootNode <- liftIO . TS.treeRootNode =<< getTree
  syntax filepath source pTable rootNode

parse :: FilePath -> IO SomeTerm
parse path =
  runReaderT parse' =<<
    newTreeSitterEnv path tree_sitter_sui_move

syntax :: FilePath -> ByteString -> ParseTable -> TS.Node -> ReaderT TreeSitterEnv IO SomeTerm
syntax path source pTable = go
  where
    pContent = Megaparsec.Cubix.getContent source
    getParser sym = IM.lookup (fromIntegral sym) (unParseTable pTable)
    go :: TS.Node -> ReaderT TreeSitterEnv IO SomeTerm
    go root = do
      extra <- liftIO $ TS.nodeIsExtra root
      if extra
        then pure $ error ""
        else do
          range    <- liftIO $ nodeRange root
          span     <- liftIO $ nodeSpan path root
          symbolNo <- liftIO $ TS.nodeSymbol root
          -- liftIO $ traceIO =<< TS.nodeTypeAsString root
          case getParser symbolNo of
            Nothing -> do
              pPrintLightBg $ "Unrecognized symbol: " <> Prelude.show symbolNo
              pPrintLightBg $ "  at: " <> Prelude.show span
              liftIO (TS.nodeTypeAsString root) >>= pPrintLightBg
              error "no parse"

            Just p -> do
              childNo <- liftIO $ TS.nodeChildCount root
              -- pPrintLightBg $ "parsed sym: " <> show sym
              -- pPrintLightBg $ "child count: " <> show childNo

              let childNums = [0..childNo - 1]
                  content = pContent range

              children <- if childNo == 0
                then do
                  -- pPrintLightBg $ "parsed sym: " <> show sym
                  pure []
                else
                  mapM (go <=< (liftIO . TS.nodeChild root)) childNums
              case Megaparsec.runParser p path (Megaparsec.Cubix.Input content children) of
                Left err -> do
                  error "no parse"
                Right item -> do
                  pPrintLightBg item
                  pure item

-- --------------------------------------------------------------------------------
-- -- Parser 
-- --------------------------------------------------------------------------------
{-+}
type SomeTerm = E ${grammarName}Term
type Parser t = Megaparsec.Cubix.Parser ${grammarName}Sig t
type TermParser l = Parser (${grammarName}Term l)
type SomeTermParser = Parser (E ${grammarName}Term)
{+-}

-- reify types
pMaybe :: Typeable l => TermParser l -> TermParser (Maybe l)
pMaybe = Megaparsec.Cubix.pMaybe
{-# INLINABLE pMaybe #-}

pPair :: (Typeable l, Typeable l') => TermParser l -> TermParser l' -> TermParser (l, l')
pPair = Megaparsec.Cubix.pPair
{-# INLINABLE pPair #-}

pSome :: Typeable l => TermParser l -> TermParser [l]
pSome = Megaparsec.Cubix.pSome
{-# INLINABLE pSome #-}

pMany :: Typeable l => TermParser l -> TermParser [l]
pMany = Megaparsec.Cubix.pMany
{-# INLINABLE pMany #-}

pSepBy :: Typeable l => TermParser l -> TermParser sep -> TermParser [l]
pSepBy = Megaparsec.Cubix.pSepBy
{-# INLINABLE pSepBy #-}

pSepBy1 :: Typeable l => TermParser l -> TermParser sep -> TermParser [l]
pSepBy1 = Megaparsec.Cubix.pSepBy1
{-# INLINABLE pSepBy1 #-}

pBetween :: Typeable l => TermParser open -> TermParser close -> TermParser l -> TermParser l
pBetween = Megaparsec.Cubix.pBetween
{-# INLINABLE pBetween #-}

pSort :: forall l. DynCase MoveTerm l => NonEmpty Char -> TermParser l
pSort = Megaparsec.Cubix.pSort @l
{-# INLINABLE pSort #-}

pSort' :: forall l. DynCase MoveTerm l => Proxy l -> NonEmpty Char -> TermParser l
pSort' = Megaparsec.Cubix.pSort' 
{-# INLINABLE pSort' #-}

pContent :: Parser Text
pContent = Megaparsec.Cubix.pContent
{-# INLINABLE pContent #-}

{-+}
${for(tokens)}
p${it.name.camelCase} :: TermParser ${it.name.sort}
p${it.name.camelCase} = ${it.name.camelCase}' <$$ Megaparsec.eof

${endfor}
{+-}

{-+}
${for(data)}
p${it.name.camelCase} :: TermParser ${it.name.sort}
p${it.name.camelCase} =
${if(it.sum)}
  choice [ Megaparsec.try ${for(it.constructors)}p${it.name.camelCase}${sep}
         , Megaparsec.try ${endfor}
         ]
${else}
${for(it.constructors)}
  ${if(it.hasChildren)}${else}pure ${endif}${it.name.camelCase}' <$$> ${it.parser}
${endfor}
${endif}
${if(it.sum)}
  where
${for(it.constructors)}
    p${it.name.camelCase} :: TermParser ${it.type.sort}
    p${it.name.camelCase} =
      ${if(it.hasChildren)}${else}pure ${endif}${it.name.camelCase}' <$$> ${it.parser}
${endfor}
${endif}

${endfor}
{+-}

--------------------------------------------------------------------------------
-- Parse Table
--------------------------------------------------------------------------------

newtype ParseTable = SymbolTable {unParseTable :: IntMap SomeTermParser}

symbolMap :: Map String SomeTermParser
symbolMap = Map.fromList
{-+}
${for(data/first)}
    [ ("${it.name.text}", E <$$> p${it.name.camelCase})
${endfor}
${for(data/rest)}
    , ("${it.name.text}", E <$$> p${it.name.camelCase})
${endfor}
${for(tokens)}
    , ("${it.symbol}", E <$$> p${it.name.camelCase})
${endfor}
    ]
{+-}

mkParseTable :: TS.Language -> IO ParseTable
mkParseTable lang = do
  count <- fromIntegral <$> TS.languageSymbolCount lang
  SymbolTable <$> foldrM
    (\id acc -> do
      symName <- TS.languageSymbolName lang id
      let mSymSing = Map.lookup (Char8.unpack symName) symbolMap
      pure (maybe acc (flip (IM.insert (fromIntegral id)) acc) mSymSing)
    )
    (IM.empty :: IntMap SomeTermParser)
    [0..count - 1]
