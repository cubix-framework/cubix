{-+}
{- |
   AUTOGENERATED FILE - DO NOT EDIT MANUALLY

   This file was generated by the gen-parser executable from cubix-tree-sitter.

   To regenerate, run:
     cabal run gen-parser -- <path-to-grammar.json> \
       --start-rule-name <start-rule> \
       --module-name ${moduleName} \
       --token-map <path-to-preserved_tokens.json> \
       -o <output-file>

   See CLAUDE.md for full instructions on adding language support.
-}
{+-}

{-# LANGUAGE OverloadedStrings #-}
{-+}
module ${moduleName} where
{+-}

import Control.Applicative.Combinators
import Control.Monad ((<=<))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Reader (ReaderT, runReaderT)
import Data.ByteString (ByteString)
import Data.ByteString.Char8 qualified as Char8
import Data.Comp.Multi (E (..))
import Data.Comp.Multi.Strategy.Classification (DynCase, caseE)
import Data.Foldable (foldrM)
import Data.Functor ((<&>))
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.List.NonEmpty (NonEmpty)
import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Maybe (catMaybes, fromJust)
import Data.Proxy (Proxy (..))
import Data.Text (Text)
import Data.Typeable (Typeable)
import Foreign.C.ConstPtr.Compat (ConstPtr (..))

import TreeSitter qualified as TS
import Text.Megaparsec qualified as Megaparsec
import Text.Megaparsec.Cubix qualified as Megaparsec.Cubix

import Cubix.ParsePretty (type RootSort)
import Cubix.TreeSitter
import Cubix.Language.SuiMove.Modularized

import Text.Pretty.Simple (pPrintDarkBg, pPrintLightBg)

parse' :: ReaderT TreeSitterEnv IO SomeTerm
parse' = do
  filepath <- getFilePath
  source <- getSource
  pTable <- liftIO . mkParseTable =<< getLanguage
  rootNode <- liftIO . TS.treeRootNode =<< getTree
  syntax filepath source pTable rootNode

{-+}
parse :: FilePath -> IO (ConstPtr lang) -> IO (Maybe (${grammarName}Term (RootSort ${grammarName}Sig)))
parse path getLang =
  newTreeSitterEnv path getLang
  >>= runReaderT parse'
  <&> caseE @_ @(RootSort ${grammarName}Sig)
{+-}

syntax :: FilePath -> ByteString -> ParseTable -> TS.Node -> ReaderT TreeSitterEnv IO SomeTerm
syntax path source pTable = fmap fromJust . go
  where
    pContent = Megaparsec.Cubix.getContent source
    getParser sym = IM.lookup (fromIntegral sym) (unParseTable pTable)
    go :: TS.Node -> ReaderT TreeSitterEnv IO (Maybe SomeTerm)
    go root = do
      extra <- liftIO $ TS.nodeIsExtra root
      if extra
        then pure Nothing
        else do
          range    <- liftIO $ nodeRange root
          span     <- liftIO $ nodeSpan path root
          symbolNo <- liftIO $ TS.nodeSymbol root
          case getParser symbolNo of
            Nothing -> do
              liftIO (TS.nodeTypeAsString root) >>= pPrintLightBg
              error $ "Unrecognized symbol: "
                   <> Prelude.show symbolNo
                   <> " at: "
                   <> Prelude.show span

            Just p -> do
              childNo <- liftIO $ TS.nodeChildCount root
              let childNums = [0..childNo - 1]
                  content = pContent range

              children <- if childNo == 0
                then
                  pure []
                else
                  catMaybes <$> mapM (go <=< (liftIO . TS.nodeChild root)) childNums
              case Megaparsec.runParser p path (Megaparsec.Cubix.Input content children) of
                Left err -> do
                  liftIO . putStrLn $ Megaparsec.errorBundlePretty err
                  pPrintLightBg =<< liftIO (TS.nodeTypeAsString root)
                  pPrintDarkBg children
                  error "no parse"
                Right item ->
                  pure (Just item)

-- --------------------------------------------------------------------------------
-- -- Parser 
-- --------------------------------------------------------------------------------
{-+}
type SomeTerm = E ${grammarName}Term
type Parser t = Megaparsec.Cubix.Parser ${grammarName}Sig t
type TermParser l = Parser (${grammarName}Term l)
type SomeTermParser = Parser (E ${grammarName}Term)
{+-}

-- reify types
pMaybe :: Typeable l => TermParser l -> TermParser (Maybe l)
pMaybe = Megaparsec.Cubix.pMaybe
{-# INLINABLE pMaybe #-}

pPair :: (Typeable l, Typeable l') => TermParser l -> TermParser l' -> TermParser (l, l')
pPair = Megaparsec.Cubix.pPair
{-# INLINABLE pPair #-}

pSome :: Typeable l => TermParser l -> TermParser [l]
pSome = Megaparsec.Cubix.pSome
{-# INLINABLE pSome #-}

pMany :: Typeable l => TermParser l -> TermParser [l]
pMany = Megaparsec.Cubix.pMany
{-# INLINABLE pMany #-}

pSepBy :: Typeable l => TermParser l -> TermParser sep -> TermParser [l]
pSepBy = Megaparsec.Cubix.pSepBy
{-# INLINABLE pSepBy #-}

pSepBy1 :: Typeable l => TermParser l -> TermParser sep -> TermParser [l]
pSepBy1 = Megaparsec.Cubix.pSepBy1
{-# INLINABLE pSepBy1 #-}

pBetween :: Typeable l => TermParser open -> TermParser close -> TermParser l -> TermParser l
pBetween = Megaparsec.Cubix.pBetween
{-# INLINABLE pBetween #-}

pSort :: forall l. DynCase MoveTerm l => NonEmpty Char -> TermParser l
pSort = Megaparsec.Cubix.pSort @l
{-# INLINABLE pSort #-}

pSort' :: forall l. DynCase MoveTerm l => Proxy l -> NonEmpty Char -> TermParser l
pSort' = Megaparsec.Cubix.pSort' 
{-# INLINABLE pSort' #-}

pContent :: Parser Text
pContent = Megaparsec.Cubix.pContent
{-# INLINABLE pContent #-}

{-+}
${for(tokens)}
p${it.name.camelCase} :: TermParser ${it.name.sort}
p${it.name.camelCase} = ${it.name.camelCase}' <$$ Megaparsec.eof

${endfor}
{+-}

{-+}
${for(data)}
p${it.name.camelCase} :: TermParser ${it.name.sort}
p${it.name.camelCase} =
${if(it.sum)}
  choice [ Megaparsec.try ${for(it.constructors)}p${it.name.camelCase}${sep}
         , Megaparsec.try ${endfor}
         ]
${else}
${for(it.constructors)}
  ${if(it.hasChildren)}${else}pure ${endif}${it.name.camelCase}' <$$> ${it.parser}
${endfor}
${endif}
${if(it.sum)}
  where
${for(it.constructors)}
    p${it.name.camelCase} :: TermParser ${it.type.sort}
    p${it.name.camelCase} =
      ${if(it.hasChildren)}${else}pure ${endif}${it.name.camelCase}' <$$> ${it.parser}
${endfor}
${endif}

${endfor}
{+-}

--------------------------------------------------------------------------------
-- Parse Table
--------------------------------------------------------------------------------

newtype ParseTable = SymbolTable {unParseTable :: IntMap SomeTermParser}

symbolMap :: Map String SomeTermParser
symbolMap = Map.fromList
{-+}
${for(data/first)}
    [ ("${it.name.text}", E <$$> p${it.name.camelCase})
${endfor}
${for(data/rest)}
    , ("${it.name.text}", E <$$> p${it.name.camelCase})
${endfor}
${for(tokens)}
    , ("${it.symbol}", E <$$> p${it.name.camelCase})
${endfor}
    ]
{+-}

mkParseTable :: TS.Language -> IO ParseTable
mkParseTable lang = do
  count <- fromIntegral <$> TS.languageSymbolCount lang
  SymbolTable <$> foldrM
    (\id acc -> do
      symName <- TS.languageSymbolName lang id
      let mSymSing = Map.lookup (Char8.unpack symName) symbolMap
      pure (maybe acc (flip (IM.insert (fromIntegral id)) acc) mSymSing)
    )
    (IM.empty :: IntMap SomeTermParser)
    [0..count - 1]
