{-# LANGUAGE OverloadedStrings #-}
{-+}
module ${moduleName} where
{+-}

import Control.Applicative.Combinators
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Reader (ReaderT, runReaderT)
import Data.Functor (($>))
import Data.List.NonEmpty (NonEmpty (..))
import Data.String (IsString (..))
import Data.Text
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import Data.Typeable (Typeable)
import Streaming.Prelude qualified as Streaming

import TreeSitter qualified as TS
import TreeSitter.SuiMove (tree_sitter_sui_move)
import Text.Megaparsec qualified as Megaparsec
import Text.Megaparsec.TreeSitter qualified as Megaparsec.TreeSitter
import Text.Megaparsec.Cubix qualified as Megaparsec.Cubix

import Cubix.ParsePretty
import Cubix.Language.SuiMove.Modularized
import Cubix.TreeSitter

{-+}
parse' :: ReaderT (TreeSitterEnv SomeSymbolSing) IO (Maybe (${grammarName}Term (RootSort ${grammarName}Sig)))
{+-}
parse' = do
  filepath <- getFilePath
  rootNode <- liftIO . TS.treeRootNode =<< getTree
  toks <- Streaming.toList_
    $ Streaming.mapMaybeM
        (\tok ->
           fmap (\sym -> tok { tokenValue = sym }) <$> getSymbol (tokenValue tok))
    $ symbols filepath rootNode

  source <- getSource
  let lexed = Megaparsec.TreeSitter.Lexed source toks
  case Megaparsec.parse pRoot filepath lexed of
    Right ast -> pure $ Just ast
    Left err -> do
      liftIO . putStrLn $ Megaparsec.errorBundlePretty err
      pure Nothing

{-+}
parse :: FilePath -> IO (Maybe (${grammarName}Term (RootSort ${grammarName}Sig)))
{+-}
parse path =
  runReaderT parse' =<<
    newTreeSitterEnv path tree_sitter_sui_move (fmap unSymbolTable . mkSymbolTable)

-- --------------------------------------------------------------------------------
-- -- Parser 
-- --------------------------------------------------------------------------------
type Parser = Megaparsec.TreeSitter.Parser SomeSymbolSing

instance IsString (NonEmpty Char) where
  fromString [] = error "NonEmpty.fromString: empty string"
  fromString (s:ss) = s :| ss

pSymbol
  :: forall (symbolType :: SymbolType) (symbol :: Symbol symbolType)
   . NonEmpty Char
  -> SymbolSing symbolType symbol
  -> Parser (Cubix.TreeSitter.Token (SymbolSing symbolType symbol))
pSymbol expected sym = Megaparsec.TreeSitter.pToken expected $ \case
  SomeSymbolSing _isReal symSing -> case decSymbolSing sym symSing of
    Just (Refl, HRefl) -> Just symSing
    Nothing -> Nothing

pText :: Parser Text
pText = pure mempty

-- reify the types to aid inference, that might get broken
{-+}
pMaybe :: Typeable a => Parser (${grammarName}Term a) -> Parser (${grammarName}Term (Maybe a))
{+-}
pMaybe = Megaparsec.Cubix.pMaybe

{-+}
pPair :: (Typeable a, Typeable b) => Parser (${grammarName}Term a) -> Parser (${grammarName}Term b) -> Parser (${grammarName}Term (a , b))
{+-}
pPair = Megaparsec.Cubix.pPair

{-+}
pEither :: (Typeable a, Typeable b) => Parser (${grammarName}Term a) -> Parser (${grammarName}Term b) -> Parser (${grammarName}Term (Either a b))
{+-}
pEither = Megaparsec.Cubix.pEither

{-+}
pSome :: Typeable a => Parser (${grammarName}Term a) -> Parser (${grammarName}Term [a])
{+-}
pSome = Megaparsec.Cubix.pSome

{-+}
pMany :: Typeable a => Parser (${grammarName}Term a) -> Parser (${grammarName}Term [a])
{+-}
pMany = Megaparsec.Cubix.pMany

{-+}
pRoot :: Parser (${grammarName}Term (RootSort ${grammarName}Sig))
pRoot = p${startSort.camelCase}
{+-}

{-+}
${for(tokens)}
p${it.name.camelCase} :: Parser (${grammarName}Term ${it.name.camelCase}TokL)
p${it.name.camelCase} = pSymbol "${it.name.text}" S${it.name.camelCase}TokSymbol $$> i${it.name.camelCase}

${endfor}
{+-}

{-+}
${for(data)}
p${it.name.camelCase} :: Parser (${grammarName}Term ${it.name.sort})
p${it.name.camelCase} = do
${if(it.hasSymbol)}
  _sym <- pSymbol "${it.name.text}" S${it.name.camelCase}Symbol
${endif}
${if(it.sum)}
  choice [ Megaparsec.try ${for(it.constructors)}p${it.name.camelCase}${sep}
         , Megaparsec.try ${endfor}
         ]
${else}
${for(it.constructors)}
  ${if(it.hasChildren)}${else}pure ${endif}i${it.name.camelCase}
${for(it.fields/first)}
    <$$> ${it.parser}
${endfor}
${for(it.fields/rest)}
    <*> ${it.parser}
${endfor}
${endfor}
${endif}
${if(it.sum)}
  where
${for(it.constructors)}
    p${it.name.camelCase} :: Parser (${grammarName}Term ${it.type.sort})
    p${it.name.camelCase} =
      ${if(it.hasChildren)}${else}pure ${endif}i${it.name.camelCase}
${for(it.fields/first)}
        <$$> ${it.parser}
${endfor}
${for(it.fields/rest)}
        <*> ${it.parser}
${endfor}
${endfor}
${endif}

${endfor}
{+-}
