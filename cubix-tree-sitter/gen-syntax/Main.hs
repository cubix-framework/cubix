{-# LANGUAGE TemplateHaskell #-}

module Main (main) where

import Data.Text (Text)
import Data.Text qualified as Text
import Data.Text.IO qualified as Text.IO
import Foreign (Ptr)
import Language.Haskell.TH (mkName, pprint, runQ)
import NeatInterpolation
import Options (Options (..))
import Options.Generic qualified as Opt
import Path qualified
import System.IO (IOMode (..), stdout)
import System.IO qualified
import TreeSitter.Language qualified
import TreeSitter.SuiMove qualified as SuiMove

import AST.GenerateSyntax

parserFor :: Text -> Ptr TreeSitter.Language.Language
parserFor = \case
  "SuiMove" -> SuiMove.tree_sitter_sui_move
  lang -> error $ "Unknown language encountered: " <> Text.unpack lang

emit
  :: Text
  -> Path.SomeBase Path.File
  -> IO Text
emit lang nodes = do
  decls <- Text.pack . pprint <$> astDeclarationsIO (parserFor lang) nodes

  pure [trimming|
-- Language definition for $lang, generated by gen-syntax. Do not edit!
{-# LANGUAGE CPP #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE QuantifiedConstraints #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# OPTIONS_GHC -fno-warn-redundant-constraints #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Language.$lang.Syntax (module Language.$lang.Syntax, getTestCorpusDir) where

-- import qualified AST.Parse
-- import qualified AST.Token
-- import qualified AST.Traversable1.Class
import qualified Data.Foldable
import qualified Data.Functor.Classes
import qualified Data.List as Data.OldList
import qualified Data.Maybe as GHC.Maybe
import qualified Data.Text.Internal
import qualified Data.Traversable
import qualified GHC.Base
import qualified GHC.Generics
import qualified GHC.Records
import qualified GHC.Show
import qualified Prelude as GHC.Classes
import qualified Prelude as GHC.Types
import qualified TreeSitter.Node

import TreeSitter.$lang (getTestCorpusDir)

debugSymbolNames :: [GHC.Base.String]
debugSymbolNames = debugSymbolNames_0

$decls
  |]

main :: IO ()
main = do
  (opts, _help) <-
    Opt.unwrapWithHelp
      "Generate Abstract Syntax Tree types based on tree-sitter language definition"

  programText <-
    emit (language opts) (nodes opts)

  handle <-
    maybe (pure stdout) (flip System.IO.openFile WriteMode . Path.fromSomeFile) $ destination opts

  Text.IO.hPutStrLn handle programText
  System.IO.hClose handle
